
image.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bootloader   0000020a  0001f000  0001f000  00000162  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .progdata     00000000  0001ff00  0001ff00  0000036c  2**0
                  CONTENTS
  2 .text         000000ae  00000000  00000000  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000000  00800060  000000ae  00000162  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000000  00800060  00800060  0000036c  2**0
                  ALLOC
  5 .noinit       00000000  00800060  00800060  0000036c  2**0
                  CONTENTS
  6 .eeprom       00000000  00810000  00810000  0000036c  2**0
                  CONTENTS
  7 .stab         00000e4c  00000000  00000000  0000036c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .stabstr      00000a6e  00000000  00000000  000011b8  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .bootloader:

0001f000 <bootloader>:
#define muh ((uint8_t *)0x9000)

int bootloader(void){
	
	cli();
   1f000:	f8 94       	cli
	
	asm volatile(
   1f002:	8f ef       	ldi	r24, 0xFF	; 255
   1f004:	9f e0       	ldi	r25, 0x0F	; 15
   1f006:	8d bf       	out	0x3d, r24	; 61
   1f008:	9e bf       	out	0x3e, r25	; 62
		"out 0x3d, %A0\n\t"
		"out 0x3e, %B0\n\t"
		::"w" (RAMEND)
	);
	
	uint8_t command, data;
	uint16_t address, size;
	
	uint8_t x;
	
	uart_init();
   1f00a:	0e 94 b5 f8 	call	0x1f16a
		
	while(1){
		command = uart_getc();
   1f00e:	0e 94 e4 f8 	call	0x1f1c8
	
		switch (command){
   1f012:	99 27       	eor	r25, r25
   1f014:	8d 36       	cpi	r24, 0x6D	; 109
   1f016:	91 05       	cpc	r25, r1
   1f018:	09 f4       	brne	.+2      	; 0x1f01c
   1f01a:	77 c0       	rjmp	.+238    	; 0x1f10a
   1f01c:	8e 36       	cpi	r24, 0x6E	; 110
   1f01e:	91 05       	cpc	r25, r1
   1f020:	84 f4       	brge	.+32     	; 0x1f042
   1f022:	84 36       	cpi	r24, 0x64	; 100
   1f024:	91 05       	cpc	r25, r1
   1f026:	09 f4       	brne	.+2      	; 0x1f02a
   1f028:	55 c0       	rjmp	.+170    	; 0x1f0d4
   1f02a:	85 36       	cpi	r24, 0x65	; 101
   1f02c:	91 05       	cpc	r25, r1
   1f02e:	24 f4       	brge	.+8      	; 0x1f038
   1f030:	82 36       	cpi	r24, 0x62	; 98
   1f032:	91 05       	cpc	r25, r1
   1f034:	c1 f1       	breq	.+112    	; 0x1f0a6
   1f036:	eb cf       	rjmp	.-42     	; 0x1f00e
   1f038:	8a 36       	cpi	r24, 0x6A	; 106
   1f03a:	91 05       	cpc	r25, r1
   1f03c:	09 f4       	brne	.+2      	; 0x1f040
   1f03e:	8c c0       	rjmp	.+280    	; 0x1f158
   1f040:	e6 cf       	rjmp	.-52     	; 0x1f00e
   1f042:	84 37       	cpi	r24, 0x74	; 116
   1f044:	91 05       	cpc	r25, r1
   1f046:	09 f4       	brne	.+2      	; 0x1f04a
   1f048:	7d c0       	rjmp	.+250    	; 0x1f144
   1f04a:	85 37       	cpi	r24, 0x75	; 117
   1f04c:	91 05       	cpc	r25, r1
   1f04e:	2c f4       	brge	.+10     	; 0x1f05a
   1f050:	82 37       	cpi	r24, 0x72	; 114
   1f052:	91 05       	cpc	r25, r1
   1f054:	09 f4       	brne	.+2      	; 0x1f058
   1f056:	85 c0       	rjmp	.+266    	; 0x1f162
   1f058:	da cf       	rjmp	.-76     	; 0x1f00e
   1f05a:	85 37       	cpi	r24, 0x75	; 117
   1f05c:	91 05       	cpc	r25, r1
   1f05e:	b9 f6       	brne	.-82     	; 0x1f00e
			case 'u'://upload
				address = getword();
   1f060:	0e 94 f8 f8 	call	0x1f1f0
   1f064:	08 2f       	mov	r16, r24
   1f066:	19 2f       	mov	r17, r25
				size = getword();
   1f068:	0e 94 f8 f8 	call	0x1f1f0
				for(;size--;address++){
   1f06c:	d9 2f       	mov	r29, r25
   1f06e:	c8 2f       	mov	r28, r24
   1f070:	21 97       	sbiw	r28, 0x01	; 1
   1f072:	8f ef       	ldi	r24, 0xFF	; 255
   1f074:	cf 3f       	cpi	r28, 0xFF	; 255
   1f076:	d8 07       	cpc	r29, r24
   1f078:	51 f2       	breq	.-108    	; 0x1f00e
						BANK_REG = (address >>8) + 0x200;
   1f07a:	81 2f       	mov	r24, r17
   1f07c:	99 27       	eor	r25, r25
   1f07e:	80 50       	subi	r24, 0x00	; 0
   1f080:	9e 4f       	sbci	r25, 0xFE	; 254
   1f082:	90 93 01 fe 	sts	0xFE01, r25
   1f086:	80 93 00 fe 	sts	0xFE00, r24
						data = uart_getc();
   1f08a:	0e 94 e4 f8 	call	0x1f1c8
						BANK_DATA[address&0xFF] = data;
   1f08e:	f1 2f       	mov	r31, r17
   1f090:	e0 2f       	mov	r30, r16
   1f092:	ff 6f       	ori	r31, 0xFF	; 255
   1f094:	80 83       	st	Z, r24
   1f096:	0f 5f       	subi	r16, 0xFF	; 255
   1f098:	1f 4f       	sbci	r17, 0xFF	; 255
   1f09a:	21 97       	sbiw	r28, 0x01	; 1
   1f09c:	ef ef       	ldi	r30, 0xFF	; 255
   1f09e:	cf 3f       	cpi	r28, 0xFF	; 255
   1f0a0:	de 07       	cpc	r29, r30
   1f0a2:	59 f7       	brne	.-42     	; 0x1f07a
				}
				break;
   1f0a4:	b4 cf       	rjmp	.-152    	; 0x1f00e
			case 'b'://binary download
				address = getword();
   1f0a6:	0e 94 f8 f8 	call	0x1f1f0
   1f0aa:	08 2f       	mov	r16, r24
   1f0ac:	19 2f       	mov	r17, r25
				size = getword();
   1f0ae:	0e 94 f8 f8 	call	0x1f1f0
				for(;size--;address++){
   1f0b2:	d9 2f       	mov	r29, r25
   1f0b4:	c8 2f       	mov	r28, r24
   1f0b6:	21 97       	sbiw	r28, 0x01	; 1
   1f0b8:	ff ef       	ldi	r31, 0xFF	; 255
   1f0ba:	cf 3f       	cpi	r28, 0xFF	; 255
   1f0bc:	df 07       	cpc	r29, r31
   1f0be:	09 f4       	brne	.+2      	; 0x1f0c2
   1f0c0:	a6 cf       	rjmp	.-180    	; 0x1f00e
					data = pgm_read_byte(address);
					uart_putc(data);
   1f0c2:	f1 2f       	mov	r31, r17
   1f0c4:	e0 2f       	mov	r30, r16
   1f0c6:	c8 95       	lpm
   1f0c8:	80 2d       	mov	r24, r0
   1f0ca:	0e 94 ba f8 	call	0x1f174
   1f0ce:	0f 5f       	subi	r16, 0xFF	; 255
   1f0d0:	1f 4f       	sbci	r17, 0xFF	; 255
   1f0d2:	f1 cf       	rjmp	.-30     	; 0x1f0b6
				}
				break;
			case 'd':
				address = getword();
   1f0d4:	0e 94 f8 f8 	call	0x1f1f0
   1f0d8:	08 2f       	mov	r16, r24
   1f0da:	19 2f       	mov	r17, r25
				size = getword();
   1f0dc:	0e 94 f8 f8 	call	0x1f1f0
				for(;size--;address++){
   1f0e0:	d9 2f       	mov	r29, r25
   1f0e2:	c8 2f       	mov	r28, r24
   1f0e4:	21 97       	sbiw	r28, 0x01	; 1
   1f0e6:	8f ef       	ldi	r24, 0xFF	; 255
   1f0e8:	cf 3f       	cpi	r28, 0xFF	; 255
   1f0ea:	d8 07       	cpc	r29, r24
   1f0ec:	09 f4       	brne	.+2      	; 0x1f0f0
   1f0ee:	8f cf       	rjmp	.-226    	; 0x1f00e
						uart_putc (*((uint8_t *) address));
   1f0f0:	f1 2f       	mov	r31, r17
   1f0f2:	e0 2f       	mov	r30, r16
   1f0f4:	81 91       	ld	r24, Z+
   1f0f6:	0e 2f       	mov	r16, r30
   1f0f8:	1f 2f       	mov	r17, r31
   1f0fa:	0e 94 ba f8 	call	0x1f174
   1f0fe:	21 97       	sbiw	r28, 0x01	; 1
   1f100:	ff ef       	ldi	r31, 0xFF	; 255
   1f102:	cf 3f       	cpi	r28, 0xFF	; 255
   1f104:	df 07       	cpc	r29, r31
   1f106:	a1 f7       	brne	.-24     	; 0x1f0f0
				}
				break;
   1f108:	82 cf       	rjmp	.-252    	; 0x1f00e
			
			
			case 'm':
				for(x = 0;x != 0xfe ;x+=2){
   1f10a:	c0 e0       	ldi	r28, 0x00	; 0
   1f10c:	8f ef       	ldi	r24, 0xFF	; 255
					muh[x] = x;
   1f10e:	ec 2f       	mov	r30, r28
   1f110:	ff 27       	eor	r31, r31
   1f112:	e0 50       	subi	r30, 0x00	; 0
   1f114:	f0 47       	sbci	r31, 0x70	; 112
   1f116:	c1 93       	st	Z+, r28
					muh[x+1] = 0xff;
   1f118:	80 83       	st	Z, r24
   1f11a:	ce 5f       	subi	r28, 0xFE	; 254
   1f11c:	ce 3f       	cpi	r28, 0xFE	; 254
   1f11e:	b9 f7       	brne	.-18     	; 0x1f10e
   1f120:	c0 e0       	ldi	r28, 0x00	; 0
				};
				
				for(x = 0;x != 0xfe ;x+=2){
					if(muh[x] != x){
   1f122:	ec 2f       	mov	r30, r28
   1f124:	ff 27       	eor	r31, r31
   1f126:	e0 50       	subi	r30, 0x00	; 0
   1f128:	f0 47       	sbci	r31, 0x70	; 112
   1f12a:	80 81       	ld	r24, Z
   1f12c:	8c 17       	cp	r24, r28
   1f12e:	31 f0       	breq	.+12     	; 0x1f13c
						uart_putc('f');
   1f130:	86 e6       	ldi	r24, 0x66	; 102
   1f132:	0e 94 ba f8 	call	0x1f174
						uart_putc(x);
   1f136:	8c 2f       	mov	r24, r28
   1f138:	0e 94 ba f8 	call	0x1f174
   1f13c:	ce 5f       	subi	r28, 0xFE	; 254
   1f13e:	ce 3f       	cpi	r28, 0xFE	; 254
   1f140:	81 f7       	brne	.-32     	; 0x1f122
					}
				};
				
				break;
   1f142:	65 cf       	rjmp	.-310    	; 0x1f00e
				
			case 't':
				for(size=0;size<256;size++){
   1f144:	c0 e0       	ldi	r28, 0x00	; 0
   1f146:	d0 e0       	ldi	r29, 0x00	; 0
					uart_putc(size);
   1f148:	8c 2f       	mov	r24, r28
   1f14a:	0e 94 ba f8 	call	0x1f174
   1f14e:	21 96       	adiw	r28, 0x01	; 1
   1f150:	cf 3f       	cpi	r28, 0xFF	; 255
   1f152:	d1 05       	cpc	r29, r1
   1f154:	c9 f3       	breq	.-14     	; 0x1f148
   1f156:	c0 f3       	brcs	.-16     	; 0x1f148
				}
				
			//case 'd'://dump
			//	address = getword();
			//	hexdump((uint8_t*)address, uart_getc());
			//	break;
			case 'j':{//jump
				void (*fp) (void);
				address = getword();
   1f158:	0e 94 f8 f8 	call	0x1f1f0
				//hexdump((uint8_t *)&address, 2);
				fp = (void (*) (void))address;
				fp();
   1f15c:	e8 2f       	mov	r30, r24
   1f15e:	f9 2f       	mov	r31, r25
   1f160:	09 95       	icall
			}
			case 'r'://ready
				uart_putc('r');
   1f162:	82 e7       	ldi	r24, 0x72	; 114
   1f164:	0e 94 ba f8 	call	0x1f174
				break;
   1f168:	52 cf       	rjmp	.-348    	; 0x1f00e

0001f16a <uart_init>:
#endif // UART_INTERRUPT


void uart_init() {
	UCR |= (1<<TXEN);			//UART TX einschalten
   1f16a:	53 9a       	sbi	0x0a, 3	; 10

	UCR |= ( 1 << RXEN );			//Uart RX einschalten
   1f16c:	54 9a       	sbi	0x0a, 4	; 10

	UBRR = 24; //(uint8_t)(UART_BAUD_CALC(UART_BAUD_RATE,F_CPU));
   1f16e:	88 e1       	ldi	r24, 0x18	; 24
   1f170:	89 b9       	out	0x09, r24	; 9
   1f172:	08 95       	ret

0001f174 <uart_putc>:

#ifdef UART_INTERRUPT
	// init buffers
	rxhead = rxtail = rxbuf;
	txhead = txtail = txbuf;

	// activate rx IRQ
	UCR |= (1 << RXCIE);
#endif // UART_INTERRUPT
}

#ifdef UART_INTERRUPT
void uart_putc(char c) {
	volatile int diff;

	/* buffer full? */
	do {
		diff = txhead - txtail;
		if ( diff < 0 ) diff += UART_TXBUFSIZE;
	} while ( diff >= UART_TXBUFSIZE -1 );

	cli();
	*txhead = c;
 	if (++txhead == (txbuf + UART_TXBUFSIZE)) txhead = txbuf;

	UCR |= (1 << UDRIE);		/* enable data register empty IRQ */
	sei();
}
#else  // WITHOUT INTERRUPT
void uart_putc(char c) {
	while (!(USR & (1<<UDRE))); /* warten bis Senden moeglich                   */
   1f174:	5d 9b       	sbis	0x0b, 5	; 11
   1f176:	fe cf       	rjmp	.-4      	; 0x1f174
	UDR = c;                      /* schreibt das Zeichen x auf die Schnittstelle */
   1f178:	8c b9       	out	0x0c, r24	; 12
   1f17a:	08 95       	ret

0001f17c <uart_putstr>:
}
#endif // UART_INTERRUPT


void uart_putstr(char *str) {
   1f17c:	cf 93       	push	r28
   1f17e:	df 93       	push	r29
   1f180:	d9 2f       	mov	r29, r25
   1f182:	c8 2f       	mov	r28, r24
	while(*str) {
		uart_putc(*str++);
   1f184:	88 81       	ld	r24, Y
   1f186:	88 23       	and	r24, r24
   1f188:	31 f0       	breq	.+12     	; 0x1f196
   1f18a:	89 91       	ld	r24, Y+
   1f18c:	0e 94 ba f8 	call	0x1f174
   1f190:	88 81       	ld	r24, Y
   1f192:	88 23       	and	r24, r24
   1f194:	d1 f7       	brne	.-12     	; 0x1f18a
   1f196:	df 91       	pop	r29
   1f198:	cf 91       	pop	r28
   1f19a:	08 95       	ret

0001f19c <uart_putstr_P>:
	}
}

void uart_putstr_P(PGM_P str) {
   1f19c:	cf 93       	push	r28
   1f19e:	df 93       	push	r29
   1f1a0:	d9 2f       	mov	r29, r25
   1f1a2:	c8 2f       	mov	r28, r24
	char tmp;
	while((tmp = pgm_read_byte(str))) {
		uart_putc(tmp);
		str++;
   1f1a4:	f9 2f       	mov	r31, r25
   1f1a6:	e8 2f       	mov	r30, r24
   1f1a8:	c8 95       	lpm
   1f1aa:	80 2d       	mov	r24, r0
   1f1ac:	88 23       	and	r24, r24
   1f1ae:	49 f0       	breq	.+18     	; 0x1f1c2
   1f1b0:	0e 94 ba f8 	call	0x1f174
   1f1b4:	21 96       	adiw	r28, 0x01	; 1
   1f1b6:	fd 2f       	mov	r31, r29
   1f1b8:	ec 2f       	mov	r30, r28
   1f1ba:	c8 95       	lpm
   1f1bc:	80 2d       	mov	r24, r0
   1f1be:	88 23       	and	r24, r24
   1f1c0:	b9 f7       	brne	.-18     	; 0x1f1b0
   1f1c2:	df 91       	pop	r29
   1f1c4:	cf 91       	pop	r28
   1f1c6:	08 95       	ret

0001f1c8 <uart_getc>:
	}
}


#ifdef UART_INTERRUPT
char uart_getc()
{
	char val;

	while(rxhead==rxtail) ;

	val = *rxtail;
 	if (++rxtail == (rxbuf + UART_RXBUFSIZE)) rxtail = rxbuf;

	return val;
}
#else  // WITHOUT INTERRUPT
char uart_getc()
{
	while (!(USR & (1<<RXC)));	// warten bis Zeichen verfuegbar
   1f1c8:	5f 9b       	sbis	0x0b, 7	; 11
   1f1ca:	fe cf       	rjmp	.-4      	; 0x1f1c8
	return UDR;			// Zeichen aus UDR zurueckgeben
   1f1cc:	8c b1       	in	r24, 0x0c	; 12
}
   1f1ce:	99 27       	eor	r25, r25
   1f1d0:	87 fd       	sbrc	r24, 7
   1f1d2:	90 95       	com	r25
   1f1d4:	08 95       	ret

0001f1d6 <uart_getc_nb>:
#endif // UART_INTERRUPT

// returns 1 on success
#ifdef UART_INTERRUPT
char uart_getc_nb(char *c)
{
	if (rxhead==rxtail) return 0;

	*c = *rxtail;
 	if (++rxtail == (rxbuf + UART_RXBUFSIZE)) rxtail = rxbuf;

	return 1;
}
#else  // WITHOUT INTERRUPT
char uart_getc_nb(char *c)
{
   1f1d6:	f9 2f       	mov	r31, r25
   1f1d8:	e8 2f       	mov	r30, r24
	if (USR & (1<<RXC)) {		// Zeichen verfuegbar
   1f1da:	5f 9b       	sbis	0x0b, 7	; 11
   1f1dc:	05 c0       	rjmp	.+10     	; 0x1f1e8
		*c = UDR;
   1f1de:	8c b1       	in	r24, 0x0c	; 12
   1f1e0:	80 83       	st	Z, r24
		return 1;
   1f1e2:	81 e0       	ldi	r24, 0x01	; 1
   1f1e4:	90 e0       	ldi	r25, 0x00	; 0
   1f1e6:	08 95       	ret
	}

	return 0;
   1f1e8:	80 e0       	ldi	r24, 0x00	; 0
   1f1ea:	90 e0       	ldi	r25, 0x00	; 0
}
   1f1ec:	08 95       	ret
   1f1ee:	08 95       	ret

0001f1f0 <getword>:
#endif // UART_INTERRUPT



uint16_t getword(){
   1f1f0:	0f 93       	push	r16
   1f1f2:	1f 93       	push	r17
	union{
		uint8_t b[2];
		uint16_t w;
	}u;
	
	u.b[0] = uart_getc();
   1f1f4:	0e 94 e4 f8 	call	0x1f1c8
   1f1f8:	08 2f       	mov	r16, r24
	u.b[1] = uart_getc();
   1f1fa:	0e 94 e4 f8 	call	0x1f1c8
   1f1fe:	18 2f       	mov	r17, r24
	return u.w;
}
   1f200:	91 2f       	mov	r25, r17
   1f202:	80 2f       	mov	r24, r16
   1f204:	1f 91       	pop	r17
   1f206:	0f 91       	pop	r16
   1f208:	08 95       	ret
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 30 00 	jmp	0x60
   4:	0c 94 50 00 	jmp	0xa0
   8:	0c 94 50 00 	jmp	0xa0
   c:	0c 94 50 00 	jmp	0xa0
  10:	0c 94 50 00 	jmp	0xa0
  14:	0c 94 50 00 	jmp	0xa0
  18:	0c 94 50 00 	jmp	0xa0
  1c:	0c 94 50 00 	jmp	0xa0
  20:	0c 94 50 00 	jmp	0xa0
  24:	0c 94 50 00 	jmp	0xa0
  28:	0c 94 50 00 	jmp	0xa0
  2c:	0c 94 50 00 	jmp	0xa0
  30:	0c 94 50 00 	jmp	0xa0
  34:	0c 94 50 00 	jmp	0xa0
  38:	0c 94 50 00 	jmp	0xa0
  3c:	0c 94 50 00 	jmp	0xa0
  40:	0c 94 50 00 	jmp	0xa0
  44:	0c 94 50 00 	jmp	0xa0
  48:	0c 94 50 00 	jmp	0xa0
  4c:	0c 94 50 00 	jmp	0xa0
  50:	0c 94 50 00 	jmp	0xa0
  54:	0c 94 50 00 	jmp	0xa0
  58:	0c 94 50 00 	jmp	0xa0
  5c:	0c 94 50 00 	jmp	0xa0

00000060 <__ctors_end>:
  60:	11 24       	eor	r1, r1
  62:	1f be       	out	0x3f, r1	; 63
  64:	cf ef       	ldi	r28, 0xFF	; 255
  66:	df e0       	ldi	r29, 0x0F	; 15
  68:	de bf       	out	0x3e, r29	; 62
  6a:	cd bf       	out	0x3d, r28	; 61

0000006c <__do_copy_data>:
  6c:	10 e0       	ldi	r17, 0x00	; 0
  6e:	a0 e6       	ldi	r26, 0x60	; 96
  70:	b0 e0       	ldi	r27, 0x00	; 0
  72:	ee ea       	ldi	r30, 0xAE	; 174
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	0f ef       	ldi	r16, 0xFF	; 255

00000078 <.__do_copy_data_carry>:
  78:	03 95       	inc	r16
  7a:	0b bf       	out	0x3b, r16	; 59
  7c:	04 c0       	rjmp	.+8      	; 0x86

0000007e <.__do_copy_data_loop>:
  7e:	d8 95       	elpm
  80:	0d 92       	st	X+, r0
  82:	31 96       	adiw	r30, 0x01	; 1
  84:	c8 f3       	brcs	.-14     	; 0x78

00000086 <.__do_copy_data_start>:
  86:	a0 36       	cpi	r26, 0x60	; 96
  88:	b1 07       	cpc	r27, r17
  8a:	c9 f7       	brne	.-14     	; 0x7e

0000008c <__do_clear_bss>:
  8c:	10 e0       	ldi	r17, 0x00	; 0
  8e:	a0 e6       	ldi	r26, 0x60	; 96
  90:	b0 e0       	ldi	r27, 0x00	; 0
  92:	01 c0       	rjmp	.+2      	; 0x96

00000094 <.do_clear_bss_loop>:
  94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
  96:	a0 36       	cpi	r26, 0x60	; 96
  98:	b1 07       	cpc	r27, r17
  9a:	e1 f7       	brne	.-8      	; 0x94
  9c:	0c 94 52 00 	jmp	0xa4

000000a0 <__bad_interrupt>:
  a0:	0c 94 00 00 	jmp	0x0

000000a4 <main>:
  a4:	cf ef       	ldi	r28, 0xFF	; 255
  a6:	df e0       	ldi	r29, 0x0F	; 15
  a8:	de bf       	out	0x3e, r29	; 62
  aa:	cd bf       	out	0x3d, r28	; 61
  ac:	ff cf       	rjmp	.-2      	; 0xac
