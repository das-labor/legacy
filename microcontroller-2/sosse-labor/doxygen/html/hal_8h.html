<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SOSSE: hal.h File Reference</title>
<link href="sos.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>hal.h File Reference</h1>HAL (Hardware Abstraction Layer) declarations. <a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="types_8h-source.html">types.h</a>&gt;</code><br>

<p>
<a href="hal_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal_8h.html#f5ea8985a12feedc3ac25fbb50712183">hal_init</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the HAL.  <a href="#f5ea8985a12feedc3ac25fbb50712183"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal_8h.html#e23736f92fbd6e59f6e67a191e69ecef">hal_eeprom_read</a> (<a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> *dst, <a class="el" href="types_8h.html#f78b002cffb8a135ab10841bc49e3e14">iu16</a> src, <a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from EEPROM.  <a href="#e23736f92fbd6e59f6e67a191e69ecef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal_8h.html#19f6e1f1e627521793f250459c5e49b8">hal_eeprom_write</a> (<a class="el" href="types_8h.html#f78b002cffb8a135ab10841bc49e3e14">iu16</a> dst, <a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> *src, <a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to EEPROM.  <a href="#19f6e1f1e627521793f250459c5e49b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal_8h.html#50f4270db8dcf34e7e98f1e2b43d1135">hal_io_sendByteT0</a> (<a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a byte with T=0 error detection and recovery.  <a href="#50f4270db8dcf34e7e98f1e2b43d1135"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal_8h.html#6f2a2f946cf90cb7bd613f2c3ada355c">hal_io_recByteT0</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a byte with T=0 error detection and recovery.  <a href="#6f2a2f946cf90cb7bd613f2c3ada355c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal_8h.html#9bf6b66f6f08018eb3de87fe98fbf361">hal_rnd_addEntropy</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds entropy to the random number generator state.  <a href="#9bf6b66f6f08018eb3de87fe98fbf361"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal_8h.html#4dfdfc55f93a2f674edd64b10e8332ae">hal_rnd_getBlock</a> (<a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns 8 random bytes.  <a href="#4dfdfc55f93a2f674edd64b10e8332ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal_8h.html#85750f9688545f3782c376eb54ec091a">hal_led</a> (char set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the LEDs on Jupiter 2 cards.  <a href="#85750f9688545f3782c376eb54ec091a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
HAL (Hardware Abstraction Layer) declarations. 
<p>
<dl compact><dt><b>Id</b></dt><dd><a class="el" href="hal_8h.html">hal.h</a>,v 1.15 2002/12/22 15:42:55 m Exp </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="e23736f92fbd6e59f6e67a191e69ecef"></a><!-- doxytag: member="hal.h::hal_eeprom_read" ref="e23736f92fbd6e59f6e67a191e69ecef" args="(iu8 *dst, iu16 src, iu8 len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a> hal_eeprom_read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#f78b002cffb8a135ab10841bc49e3e14">iu16</a>&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a>&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data from EEPROM. 
<p>
The internal EEPROM begins at address 0, the external EEPROM is located subsequently.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to destination area. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>EEPROM source address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length of data in bytes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>on failure. Error code given in sw. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19f6e1f1e627521793f250459c5e49b8"></a><!-- doxytag: member="hal.h::hal_eeprom_write" ref="19f6e1f1e627521793f250459c5e49b8" args="(iu16 dst, iu8 *src, iu8 len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a> hal_eeprom_write           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#f78b002cffb8a135ab10841bc49e3e14">iu16</a>&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a>&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write data to EEPROM. 
<p>
The internal EEPROM begins at address 0, the external EEPROM is located subsequently.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>EEPROM destination address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to source area. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length of data in bytes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>on failure. Error code given in sw. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f5ea8985a12feedc3ac25fbb50712183"></a><!-- doxytag: member="hal.h::hal_init" ref="f5ea8985a12feedc3ac25fbb50712183" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hal_init           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the HAL. 
<p>
Must be called after each reset. 
</div>
</div><p>
<a class="anchor" name="6f2a2f946cf90cb7bd613f2c3ada355c"></a><!-- doxytag: member="hal.h::hal_io_recByteT0" ref="6f2a2f946cf90cb7bd613f2c3ada355c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> hal_io_recByteT0           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a byte with T=0 error detection and recovery. 
<p>
Currently only 9600 bps at 3.58MHz with direct convention is supported.<p>
<dl compact><dt><b>Returns:</b></dt><dd>This function returns a received byte. There can't be an error, because T=0 tries endlessly to receive a characters. (And if there is really an error, what should SOSSE do with it anyway?) </dd></dl>

</div>
</div><p>
<a class="anchor" name="50f4270db8dcf34e7e98f1e2b43d1135"></a><!-- doxytag: member="hal.h::hal_io_sendByteT0" ref="50f4270db8dcf34e7e98f1e2b43d1135" args="(iu8 b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hal_io_sendByteT0           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a>&nbsp;</td>
          <td class="paramname"> <em>b</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a byte with T=0 error detection and recovery. 
<p>
Currently only 9600 bps at 3.58MHz with direct convention is supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Byte to send. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="85750f9688545f3782c376eb54ec091a"></a><!-- doxytag: member="hal.h::hal_led" ref="85750f9688545f3782c376eb54ec091a" args="(char set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a> hal_led           </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the LEDs on Jupiter 2 cards. 
<p>
This can be used for example for debugging to show some state or to get a Nightrider feeling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td>Bits 0-6 are currently used for specifying LEDs.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>is currently returned</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>This function is always included when compiling for the AT90S8535, which is AFAIK the only processor, which is available as PCB with LEDs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9bf6b66f6f08018eb3de87fe98fbf361"></a><!-- doxytag: member="hal.h::hal_rnd_addEntropy" ref="9bf6b66f6f08018eb3de87fe98fbf361" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a> hal_rnd_addEntropy           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds entropy to the random number generator state. 
<p>
<b>The idea:</b> Adding real randomness to the RAND_STATE via random events and a high speed timer.<p>
<b>The implementation:</b> Timer 0 is started at the beginning and incremented every clock cycle, i.e. normally 3.58 million times per second. The timer is read at the beginning and at the end of the execution of every command. After every 8 timer values gathered in this way, RAND_STATE is read and encrypted with RAND_STATE and timer values as key. The result is written back to RAND_STATE.<p>
<b>The analysis:</b> The analysis has been done by calculating the difference of each consecutive timer value pair. From these value two distributions are build. The first is the frequency for the timer value differences within the command and the second is the frequency for the timer value differences outside the command, i.e. while communicating with the terminal. The command used for this evaluation is the Read EEPROM command (80 04 18 00 10), which should have a relatively constant execution time and does not receive bytes from the terminal.<p>
<b>Terminal randomness:</b> As expected the randomness of the distribution depends on the external system, i.e. card reader and host. Different distributions have been seen e.g. for Towitoko Chipdrive and Intertext IX2. This randomness can increas the randomness in the RAND_STATE buffer, when the card is in the hand of the owner of the card. By this, it changes RAND_STATE in a non-deterministic way for the institution writing the starting value of RAND_STATE<p>
<b>Command randomness:</b> Because there is no obvious possibility for different runtimes, the expected result would be to have exactly the same delta values for all command runs, but this is not the case. The result is a 9 - 10 ticks wide curved distribution. The reason for this might be the I2C routine communicating with the external EEPROM, because Get Response and Read EE in the internal EEPROM area have the expected result with a single delta value. Independed of the source of the clock tick variations, there is probably not much non-determinism for a skilled attacker, because he can count the clocks a command has executed.<p>
<dl compact><dt><b>Note:</b></dt><dd>This function and the initialization in <a class="el" href="hal-emu_8c.html#f5ea8985a12feedc3ac25fbb50712183">hal_init()</a> is currently commented out.</dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>on failure. Error code given in sw. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4dfdfc55f93a2f674edd64b10e8332ae"></a><!-- doxytag: member="hal.h::hal_rnd_getBlock" ref="4dfdfc55f93a2f674edd64b10e8332ae" args="(iu8 *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#97a80ca1602ebf2303258971a2c938e2">bool</a> hal_rnd_getBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#95a7dea5cbac1a117a50dccc69944d6e">iu8</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns 8 random bytes. 
<p>
<em>The current AVR implementation does not produce real random numbers, but pseudo random numbers. These are produced by a X9.17 generator modified to use a counter instead of a timer. The state of this PRNG is held at RAND_STATE_ADDR. The start value (at least the key) at this address should be unique for every card.</em><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to the destination, where the 8 random bytes should be written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>on failure. Error code given in sw.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>There is still a simpler PRNG in the code, which uses 16 bytes RAM and 126 bytes ROM less than the X9.17 generator. </dd></dl>

</div>
</div><p>
<hr><address><small>
Copyright 2002 by Matthias Bruestle. This is licensed under the GNU
General Public License.
</small></address>
</body>
</html>
