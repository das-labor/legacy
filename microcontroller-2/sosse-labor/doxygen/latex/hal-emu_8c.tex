\subsection{hal-emu.c File Reference}
\label{hal-emu_8c}\index{hal-emu.c@{hal-emu.c}}
HAL emulation for Linux. 

{\tt \#include $<$config.h$>$}\par
{\tt \#include $<$sio/sio.h$>$}\par
{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include $<$string.h$>$}\par
{\tt \#include $<$crypt.h$>$}\par
{\tt \#include $<$sw.h$>$}\par
{\tt \#include $<$types.h$>$}\par
{\tt \#include $<$sys/types.h$>$}\par
{\tt \#include $<$sys/stat.h$>$}\par
{\tt \#include $<$fcntl.h$>$}\par
{\tt \#include $<$unistd.h$>$}\par
{\tt \#include $<$errno.h$>$}\par
\subsubsection*{Defines}
\begin{CompactItemize}
\item 
\#define \bf{PORT}~\char`\"{}/dev/tty\-S0\char`\"{}
\end{CompactItemize}
\subsubsection*{Functions}
\begin{CompactItemize}
\item 
void \bf{hal\_\-init} (void)
\begin{CompactList}\small\item\em Initializes the HAL. \item\end{CompactList}\item 
void \bf{hal\_\-destroy} (void)
\item 
\bf{bool} \bf{hal\_\-eeprom\_\-read} (\bf{iu8} $\ast$dst, \bf{iu16} src, \bf{iu8} len)
\begin{CompactList}\small\item\em Read data from EEPROM. \item\end{CompactList}\item 
\bf{bool} \bf{hal\_\-eeprom\_\-write} (\bf{iu16} dst, \bf{iu8} $\ast$src, \bf{iu8} len)
\begin{CompactList}\small\item\em Write data to EEPROM. \item\end{CompactList}\item 
void \bf{hal\_\-io\_\-send\-Byte\-T0} (\bf{iu8} b)
\begin{CompactList}\small\item\em Send a byte with T=0 error detection and recovery. \item\end{CompactList}\item 
\bf{iu8} \bf{hal\_\-io\_\-rec\-Byte\-T0} (void)
\begin{CompactList}\small\item\em Receive a byte with T=0 error detection and recovery. \item\end{CompactList}\item 
\bf{bool} \bf{hal\_\-rnd\_\-get\-Block} (\bf{iu8} $\ast$dst)
\begin{CompactList}\small\item\em Returns 8 random bytes. \item\end{CompactList}\end{CompactItemize}
\subsubsection*{Variables}
\begin{CompactItemize}
\item 
\bf{iu8} \bf{eeprom} [1 $\ast$1024]
\item 
int \bf{halsend}
\end{CompactItemize}


\subsubsection{Detailed Description}
HAL emulation for Linux. 

\begin{Desc}
\item[Id]\doxyref{hal-emu.c}{p.}{hal-emu_8c},v 1.18 2003/03/30 12:42:21 m Exp \end{Desc}


\subsubsection{Define Documentation}
\index{hal-emu.c@{hal-emu.c}!PORT@{PORT}}
\index{PORT@{PORT}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}\#define PORT~\char`\"{}/dev/tty\-S0\char`\"{}}\hfill\label{hal-emu_8c_614217d263be1fb1a5f76e2ff7be19a2}




\subsubsection{Function Documentation}
\index{hal-emu.c@{hal-emu.c}!hal_destroy@{hal\_\-destroy}}
\index{hal_destroy@{hal\_\-destroy}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}void hal\_\-destroy (void)}\hfill\label{hal-emu_8c_f989aaa3712fd474689c704133f0692b}


\index{hal-emu.c@{hal-emu.c}!hal_eeprom_read@{hal\_\-eeprom\_\-read}}
\index{hal_eeprom_read@{hal\_\-eeprom\_\-read}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}\bf{bool} hal\_\-eeprom\_\-read (\bf{iu8} $\ast$ {\em dst}, \bf{iu16} {\em src}, \bf{iu8} {\em len})}\hfill\label{hal-emu_8c_e23736f92fbd6e59f6e67a191e69ecef}


Read data from EEPROM. 

The internal EEPROM begins at address 0, the external EEPROM is located subsequently.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em dst}]Pointer to destination area. \item[{\em src}]EEPROM source address. \item[{\em len}]Length of data in bytes.\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em TRUE}]on success. \item[{\em FALSE}]on failure. Error code given in sw. \end{description}
\end{Desc}
\index{hal-emu.c@{hal-emu.c}!hal_eeprom_write@{hal\_\-eeprom\_\-write}}
\index{hal_eeprom_write@{hal\_\-eeprom\_\-write}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}\bf{bool} hal\_\-eeprom\_\-write (\bf{iu16} {\em dst}, \bf{iu8} $\ast$ {\em src}, \bf{iu8} {\em len})}\hfill\label{hal-emu_8c_19f6e1f1e627521793f250459c5e49b8}


Write data to EEPROM. 

The internal EEPROM begins at address 0, the external EEPROM is located subsequently.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em dst}]EEPROM destination address \item[{\em src}]Pointer to source area. \item[{\em len}]Length of data in bytes.\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em TRUE}]on success. \item[{\em FALSE}]on failure. Error code given in sw. \end{description}
\end{Desc}
\index{hal-emu.c@{hal-emu.c}!hal_init@{hal\_\-init}}
\index{hal_init@{hal\_\-init}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}void hal\_\-init (void)}\hfill\label{hal-emu_8c_f5ea8985a12feedc3ac25fbb50712183}


Initializes the HAL. 

Must be called after each reset. \index{hal-emu.c@{hal-emu.c}!hal_io_recByteT0@{hal\_\-io\_\-recByteT0}}
\index{hal_io_recByteT0@{hal\_\-io\_\-recByteT0}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}\bf{iu8} hal\_\-io\_\-rec\-Byte\-T0 (void)}\hfill\label{hal-emu_8c_6f2a2f946cf90cb7bd613f2c3ada355c}


Receive a byte with T=0 error detection and recovery. 

Currently only 9600 bps at 3.58MHz with direct convention is supported.

\begin{Desc}
\item[Returns:]This function returns a received byte. There can't be an error, because T=0 tries endlessly to receive a characters. (And if there is really an error, what should SOSSE do with it anyway?) \end{Desc}
\index{hal-emu.c@{hal-emu.c}!hal_io_sendByteT0@{hal\_\-io\_\-sendByteT0}}
\index{hal_io_sendByteT0@{hal\_\-io\_\-sendByteT0}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}void hal\_\-io\_\-send\-Byte\-T0 (\bf{iu8} {\em b})}\hfill\label{hal-emu_8c_50f4270db8dcf34e7e98f1e2b43d1135}


Send a byte with T=0 error detection and recovery. 

Currently only 9600 bps at 3.58MHz with direct convention is supported.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em b}]Byte to send. \end{description}
\end{Desc}
\index{hal-emu.c@{hal-emu.c}!hal_rnd_getBlock@{hal\_\-rnd\_\-getBlock}}
\index{hal_rnd_getBlock@{hal\_\-rnd\_\-getBlock}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}\bf{bool} hal\_\-rnd\_\-get\-Block (\bf{iu8} $\ast$ {\em dst})}\hfill\label{hal-emu_8c_4dfdfc55f93a2f674edd64b10e8332ae}


Returns 8 random bytes. 

{\em The current AVR implementation does not produce real random numbers, but pseudo random numbers. These are produced by a X9.17 generator modified to use a counter instead of a timer. The state of this PRNG is held at RAND\_\-STATE\_\-ADDR. The start value (at least the key) at this address should be unique for every card.\/}

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em dst}]Pointer to the destination, where the 8 random bytes should be written.\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em TRUE}]on success. \item[{\em FALSE}]on failure. Error code given in sw.\end{description}
\end{Desc}
\begin{Desc}
\item[Note:]There is still a simpler PRNG in the code, which uses 16 bytes RAM and 126 bytes ROM less than the X9.17 generator. \end{Desc}


\subsubsection{Variable Documentation}
\index{hal-emu.c@{hal-emu.c}!eeprom@{eeprom}}
\index{eeprom@{eeprom}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}\bf{iu8} \bf{eeprom}[1 $\ast$1024]}\hfill\label{hal-emu_8c_f9f13c6e307e56818b6c7b54da194fdf}


\index{hal-emu.c@{hal-emu.c}!halsend@{halsend}}
\index{halsend@{halsend}!hal-emu.c@{hal-emu.c}}
\paragraph{\setlength{\rightskip}{0pt plus 5cm}int \bf{halsend}}\hfill\label{hal-emu_8c_0daf42abcdf1a78febf9353bfdc2f773}


