################################################################
############# just another ruby hacker oneliner ################
################################################################

print ',rekcah ybuR rehtona tsuJ'.reverse

print %q/92G5S="!A;F]T:&5R(%)U8GD@:&%C:V5R+```/.unpack('u')

print %q/SnVzdCBhbm90aGVyIFJ1YnkgaGFja2VyLA==/.unpack('m')

print 'Whfg nabgure Ehol unpxre,'.tr('A-Za-z', 'N-ZA-Mn-za-m')

print({'ruby' => 'Just another Ruby hacker,'}['ruby'])

print 'jUsT aNoThEr '.capitalize, 'RuBy HaCkEr,'.capitalize

print ['Just another Ruby hacker,'][0]

print ['hacker,', 'Ruby ', 'another ', 'Just '].reverse

proc {print 'Just another Ruby hacker,'}.call

def pri() print 'Just another Ruby hacker,' end; pri

for i in 'Just another Ruby hacker,' do print i end

print `echo -n Just another Ruby hacker,`

print 'Just another Ruby hacker,'.split('')

print 'JQust aQnotQher RQuby hQackQer,'.delete('Q')

'Just another Ruby hacker,'.scan(/(.)/) {print $1}

print 'Just ' + 'another ' + 'Ruby ' + 'hacker,'

print ['4a75737420616e6f746865722052756279206861636b65722c'].pack('H*')

print 'Just another Ruby hacker,'.split(/(.)/)

print %w(Just another Ruby hacker,).join(' ')

print({'another '=>'Just ', 'hacker,'=>'Ruby '}.invert.sort)

print eval(%-eval %: %|Just another Ruby hacker,| :-)

#;eval %qPprint eval %-eval %:'Just another Ruby hacker,' :-P

print Hash.new('Just another Ruby hacker,')[:Ruby]

print ['Just ', ['another ', ['Ruby ', ['hacker,']]]].flatten

print Struct.new(*%w|Ruby Just another Ruby hacker,|)[*[0]*4].members.join(' ')

print Time.now.strftime('Just another Ruby hacker,')

print "   Just another Ruby hacker,    \r\n".strip

print ['Just ', nil, 'another ', nil, 'Ruby ', nil, 'hacker,'].compact

['hacker,', 'Ruby ', 'another ', 'Just '].reverse_each do |x| print x end

/Just another Ruby hacker,/.source.display

send :print, 'Just another Ruby hacker,'

print ['Just ', 'another ', 'Ruby '] | ['another ', 'Ruby ', 'hacker,']

print ['Just ', 'another ', 'Perl', 'Ruby ', 'hacker,'] - ['Perl']

print [['', 'Just another Ruby hacker,']].assoc('')

print ['Just another Ruby hacker,'].pack('a*')

print 'Just another Ruby hacker,'.unpack('a*')

print [['Just another Ruby hacker,'].pop].sort.shift

print [['Just another Ruby hacker,', '']].rassoc('')

{'Just another ' => 'Ruby hacker,'}.to_a.display

print 'Just another Ruby hackeq,'.succ

print 'jUST ANOTHER rUBY HACKER,'.swapcase

print ['Just another Ruby hacker,'].find {|x| x}

print %w(Just another Ruby hacker,).find_all {|x| x}.join(' ')

print %w(Just another Ruby hacker,).grep(/./).join(' ')

Ruby = 'Just another Ruby hacker,' and print Object.const_get(:Ruby)

Proc.new {print 'Just another Ruby hacker,'}[]

print 'JJuusstt  aannootthheerr  RRuubbyy  hhaacckkeerr,,'.squeeze

print [1249211252, 543256175, 1952998770, 542274914, 2032167009, 1667982706].pack('N*'), ','

$> << 'Just ' << 'another ' << 'Ruby ' << 'hacker,'

5.times do|i|'Jaebcunrykso  ettRhr hua,'.scan(/.{5}/) do print $&[i,1] end end

a=',rekcah ybuR rehtona tsuJ'.split('');print a.pop while not a.empty?

print ',Pr-eok,c"a$h! kypbquuRA %roeqhbtaoon;ab rtesbujJ&'.gsub(/(.)./, '\1').reverse

print /.*/.match('Just another Ruby hacker,')

print $& if /.*/ === 'Just another Ruby hacker,'

case 'Just another Ruby hacker,' when /.*/; print $~[0] end

print Marshal.load(Marshal.dump("Just another Ruby hacker,"))

'Just another Ruby hacker,'.each_byte do |x| print x.chr end

print '/hacker,/another /Ruby /Just '.split('/').sort.values_at(1,3,2,4)

print 'Just another Perl hacker,'.sub('Perl', 'Ruby')

#$><<'RbyckJust another,'.split('').values_at(5..16,9,0,6,1,2,9,14,10,3,4,15..17)

('a'..'y').to_a.join.tr('a-y','Just another Ruby hacker,').display

begin print 'Just another ' ensure print 'Ruby hacker,' end

'J,ursetk caanho tyhbeurR  Rruebhyt ohnaac ktesru,J'.scan(/.(.)/).reverse.display

'J,ursetk caanho tyhbeurR  Rruebhyt ohnaac ktesru,J'.gsub(/(.)./,'\1').display

a='J,ursetk caanho tyhbeurR ';0.step(24,2){|i|print a[i,1]};23.step(1,-2){|i|print a[i,1]}

a='Js nte uyhce,rka bRrhoatu'.split('');12.times{print a.shift,a.pop};print a

a='Js nte uyhce,rka bRrhoatu';begin a.sub!(/^(.)(.*)(.)$/){print $1,$3;$2}end while$1;print a

a='J Ruby hacker,ust another';11.times{a.sub!(/^(.)(.*)(.)$/,'\1\3\2')};print a

print 'Just. another! -Ruby? $hacker,'.tr_s('-.!?$ ', ' ')

' e m r,yJaRnafatbpcuekewhjhskvngohrlrxsctdtiubuoyq'.scan(/(.)(.)/).collect!{|x|[x[1],x[0]]}.sort.collect!{|x|x[1]}.display

'e m r y,aJnRfatapbuckewejhshvkgnholrxrcsdtitbuouqy'.scan(/../).sort.collect!{|x|x[1,1]}.display

'4a75737420616e6f746865722052756279206861636b65722c'.scan(/../){print $&.hex.chr}

print ['Just another Perl hacker,'].fill('Just another Ruby hacker,')

$><<{1=>'Just ',2=>'another ',3=>'Ruby ',4=>'hacker,'}.sort.to_s.delete('1-4')

Kernel.print %q<Just another Ruby hacker,>

class Just_another_Ruby_hackerq;end;print Just_another_Ruby_hackerq.to_s.tr('_q',' ,')

Kust_another_Ruby_hacker=0;print Module.constants.grep(/Kust/)[0].tr('K_','J '), ','

module Lust_another_Ruby_hackerq; print name.tr('L_q', 'J ,') end

class Bar; print 'Just another Ruby hacker,' end

class Baz; def initialize() print 'Just another Ruby hacker,' end end; Baz.new

eval "A<')I;G0@)TIU<W0@86YO=&AE<B!2=6)Y(&AA8VME<BPG".unpack('u')[0]

eval "cHJpbnQgJ0p1c3QgYW5vdGhlciBSdWJ5IGhhY2tlciwn".unpack('m')[0]

$stdout.write 'Just another Ruby hacker,'

"Just \nanother \nRuby \nhacker,\n".each do |x| print x.chomp end

print $' if /\n/x === "\nJust another Ruby hacker,"

raise 'Just another Ruby hacker,' rescue print $!

print File.basename('~/Just another Ruby hacker,.rb','.*')

proc{|x|x['Just another Ruby hacker,']}[proc{|x|print x}]

method(:print)['Just another Ruby hacker,']

'Just another Ruby hacker,'.method(:display)[]

print ''.replace('Just another Ruby hacker,')

instance_eval do print 'Just another Ruby hacker,' end

Kernel.module_eval do print 'Just another Ruby hacker,' end

print %%\%s%%%%Just another Ruby hacker,%%%%%%%%%

print !?????:???%?Just another Ruby hacker,?:??

#({}.default='Just another Ruby hacker,')[0].display

print Hash['Just another ', 'Ruby hacker,']

print 'Just ' 'another ' 'Ruby ' 'hacker,'

print File.dirname('Just another Ruby hacker,/Just another Ruby porter,')

def $_.singleton_method_added(*) print 'Just another Ruby hacker,' end

print ['Just another Ruby hacker,'].delete_at(0)

print '%s %s %s %s' % %w[Just another Ruby hacker,]

'cker,by haer RuanothJust '.scan(/.{5}/).reverse.display

(97..121).to_a.pack('c*').tr('a-y','Just another Ruby hacker,').display

'abcdefghijklmnopqrstuvwxy'.tr('a-y','Just another Ruby hacker,').display

',rekcah ybuR rehtona tsuJ'.scan(/.{1}/).reverse.display

print 'Just another Ruby hacker,'%%; (^_^;;;

print('Just another Ruby hacker,'% %- ;-)

'r,keac hbyRur heotant usJ'.scan(/.{1,2}/).reverse.display

print 'Just another Ruby hacker,' * ('Just another Ruby hacker,' =~ /u/)

print 'uJtsa onhtreR bu yahkcre,'.unpack('v12c').pack('n12c')

print 'uJtsa onhtreR bu yahkcre,'.gsub(/(.)(.?)/, '\2\1')

'uJtsa onhtreR bu yahkcre,'.scan(/(.)(.?)/){|x,y| print y+x}

print 'Just another Ruby hacker,'['Just another Ruby hacker,']

print 'Just another Ruby hacker,'[/.*/]

print [].push('Just ', 'another ', 'Ruby ', 'hacker,')

print 'Just another Ruby hacker,'[0..-1]

print 'Just another Ruby hacker,'.instance_eval{self}

class String; def +@() print self end; +'Just another Ruby hacker,' end

print '1J2u3s4t5 6a7n8o9t0h1e2r3 4R5u6b7y8 9h0a1c2k3e4r5,'.delete('0-9')

'Jaubsctd eafngohtihjekrl mRnuobpyq rhsatcukvewrx,y'.gsub(/(.)./, '\1').display

#$><<{'Just another Ruby hacker,'=>''}.default=0

print eval('Just another Ruby hacker,'.dump)

print 'Just another Ruby hacker'.concat(?,)

print 'Just another Ruby hacker,'.intern.to_s

print 'Just another Ruby hacker,'.dump[1..-2]

'Just another Ruby hacker,'.each_line do |x| print x end

['JUST ANOTHER ', 'RUBY HACKER,'].each do |x| print x.capitalize end

printf '%.25s', 'Just another Ruby hacker,JARH'

print 'Just another Ruby hacker,'.split(/Z/)[0]

print 'Just another Ruby hacker,'.split(//)

print %w.J u s t \ a n o t h e r \ R u b y \ h a c k e r ,.

print String([%[Just another Ruby hacker,]])

print catch(:x){throw :x, 'Just another Ruby hacker,'}

r,w = IO::pipe;w.print 'Just another Ruby hacker,';w.close;print r.gets

print sprintf('%s', format('%s' % '%s', 'Just another Ruby hacker,'))

print eval('Just another Ruby hacker,'.inspect)

/#{print 'Just another Ruby hacker,'}/

print 'Just another Ruby hacker,'.scan(/./).collect{|x|x[0]}.pack('U*')

print 'Just another Ruby hacker,'.scan(/./).pack('a'*25)

'Just another Ruby hacker,'.send 'yalpsid'.reverse.intern

print %w.Just another Ruby Ruby Ruby hacker,..uniq.join(' ')

{}.fetch(:x){'Just another Ruby hacker,'}.display

{}.delete(:x){'Just another Ruby hacker,'}.display

print [:x].map{'Just another Ruby hacker,'}

{'Ruby hacker,'=>'Just another'}.each{|*x|print x.reverse.join(' ')}

print [].unshift('Ruby hacker,').unshift('Just another').join(' ')

{3=>'Ruby ',2=>'another ',4=>'hacker,',1=>'Just '}.values_at(1,2,3,4).display

print [[0,'Just another Ruby hacker,'],1].first.last

{''=>'JARH'}.update(''=>'Just another Ruby hacker,').display

{:JARH => 'Just another Ruby hacker,'}.values.display

{'Just another Ruby hacker,'=>:JARH}.invert[:JARH].display

print ['Just another Ruby hacker,'=>:JARH][0].keys

print [{}].slice(0..0)[0].store('', 'Just another Ruby hacker,')

print 'Just another Ruby hacker,'.split.join(' ')

begin print 'Just another Ruby hacker,' end while false

begin rescue then else print 'Just another Ruby hacker,' end

print //.match('Just another Ruby hacker,').string

callcc{print 'Just another Ruby hacker,'}

Thread.start{print'Just another Ruby hacker,'}.join

('JARH'..'Just another Ruby hacker,').end.display

('Just another'..'Ruby hacker,').to_s.tr_s('.', ' ').display

unless true then else 'Just another Ruby hacker,' end.display

loop do print 'Just another Ruby hacker,'; break end 

1.times do print 'Just another Ruby hacker,' end

0.upto(0) do print 'Just another Ruby hacker,' end

0.downto(0) do print 'Just another Ruby hacker,' end

print Struct.new('Just_another_Ruby_hacker').to_s.split(':')[2].tr('_',' '),','

def (x='Just another Ruby hacker,').foo() print self end; x.foo

begin print 'Just another Ruby hacker,' end until true

for i in %w[Just\  another\  Ruby\  hacker,] do print i end

'Just another Ruby hacker,'.each_byte do |x| putc x end

',rekcah ybuR rehtona tsuJ'.scan(/./).reverse_each do |x| putc x end

print Regexp.quote('Just another Ruby hacker,').delete('\\')

print true ? "Just another Ruby hacker," :-P

print true ? "Just another Ruby hacker," :-D

print *("Just another Ruby hacker,".."Just another Ruby hacker,").to_a

print eval(%<%%Just another Ruby hacker,%>)

print case when true then "Just another Ruby hacker," end

print %w[Just another Ruby hacker,] * " "

begin end if print "Just another Ruby hacker,"

print begin "Just another Ruby hacker," end

print "Just another Ruby hacker,".center(10000).strip

print "Just " or print "another " or print "Ruby " or print "hacker,"

print :"Just another Ruby hacker,"



######## HANDY ONE-LINERS FOR RUBY - November 16, 2005 #########
###### by David P Thomas <davidpthomas@gmail.com> - v1.0 #######
############ http://www.fepus.net/ruby1line.txt ################

# FILE SPACING:

# double space a file
    $ cat <file> | ruby -pe 'puts'
# triple space a file
    $ cat <file> | ruby -pe '2.times {puts}'
# undo double-spacing (w/ and w/o whitespace in lines)
    $ cat <file> | ruby -lne 'BEGIN{$/="\n\n"}; puts $_'
    $ cat <file> | ruby -ne 'BEGIN{$/="\n\n"}; puts $_.chomp'
    $ cat <file> | ruby -e 'puts STDIN.readlines.to_s.gsub(/\n\n/, "\n")'


# NUMBERING:

# number each line of a file (left justified).
    $ cat <file> | ruby -ne 'printf("%-6s%s", $., $_)'
# number each line of a file (right justified).
    $ cat <file> | ruby -ne 'printf("%6s%s", $., $_)'
# number each line of a file, only print non-blank lines
    $ cat <file> | ruby -e 'while gets; end; puts $.'
# count lines (emulates 'wc -l')
    $ cat <file> | ruby -ne 'END {puts $.}'
    $ cat <file> | ruby -e 'while gets; end; puts $.'


# TEXT CONVERSION AND SUBSTITUTION:

# convert DOS newlines (CR/LF) to Unix format (LF)
# - strip newline regardless; re-print with unix EOL
    $ cat <file> | ruby -ne 'BEGIN{$\="\n"}; print $_.chomp'

# convert Unix newlines (LF) to DOS format (CR/LF)
# - strip newline regardless; re-print with dos EOL
    $ cat <file> | ruby -ne 'BEGIN{$\="\r\n"}; print $_.chomp'

# delete leading whitespace (spaces/tabs/etc) from beginning of each line
    $ cat <file> | ruby -pe 'gsub(/^\s+/, "")'

# delete trailing whitespace (spaces/tabs/etc) from end of each line
# - strip newline regardless; replace with default platform record separator
    $ cat <file> | ruby -pe 'gsub(/\s+$/, $/)'

# delete BOTH leading and trailing whitespace from each line
    $ cat <file> | ruby -pe 'gsub(/^\s+/, "").gsub(/\s+$/, $/)'

# insert 5 blank spaces at the beginning of each line (ie. page offset)
    $ cat <file> | ruby -pe 'gsub(/%/, "   ")'
    # FAILS! $ cat <file> | ruby -pe 'gsub(/%/, 5.times{putc " "})'

# align all text flush right on a 79-column width
    $ cat <file> | ruby -ne 'printf("%79s", $_)'

# center all text in middle of 79-column width
    $ cat <file> | ruby -ne 'puts $_.chomp.center(79)'
    $ cat <file> | ruby -lne 'puts $_.center(79)'

# substitute (find and replace) "foo" with "bar" on each line
    $ cat <file> | ruby -pe 'gsub(/foo/, "bar")'

# substitute "foo" with "bar" ONLY for lines which contain "baz"
    $ cat <file> | ruby -pe 'gsub(/foo/, "bar") if $_ =~ /baz/'

# substitute "foo" with "bar" EXCEPT for lines which contain "baz"
    $ cat <file> | ruby -pe 'gsub(/foo/, "bar") unless $_ =~ /baz/'

# substitute "foo" or "bar" or "baz".... with "baq"
    $ cat <file> | ruby -pe 'gsub(/(foo|bar|baz)/, "baq")'

# reverse order of lines (emulates 'tac') IMPROVE
    $ cat <file> | ruby -ne 'BEGIN{@arr=Array.new}; @arr.push $_; END{puts @arr.reverse}'

# reverse each character on the line (emulates 'rev')
    $ cat <file> | ruby -ne 'puts $_.chomp.reverse'
    $ cat <file> | ruby -lne 'puts $_.reverse'

# join pairs of lines side-by-side (like 'paste')
    $ cat <file> | ruby -pe '$_ = $_.chomp + " " + gets if $. % 2'

# if a line ends with a backslash, append the next line to it
    $ cat <file> | ruby -pe 'while $_.match(/\\$/); $_ = $_.chomp.chop + gets; end'
    $ cat <file> | ruby -e 'puts STDIN.readlines.to_s.gsub(/\\\n/, "")'

# if a line begins with an equal sign, append it to the previous line (Unix)
    $ cat <file> | ruby -e 'puts STDIN.readlines.to_s.gsub(/\n=/, "")'

# add a blank line every 5 lines (after lines 5, 10, 15, etc)
    $ cat <file> | ruby -pe 'puts if $. % 6 == 0'


# SELECTIVE PRINTING OF CERTAIN LINES

# print first 10 lines of a file (emulate 'head')
    $ cat <file> | ruby -pe 'exit if $. > 10'

# print first line of a file (emulate 'head -1')
    $ cat <file> | ruby -pe 'puts $_; exit'

# print the last 10 lines of a file (emulate 'tail'); NOTE reads entire file!
    $ cat <file> | ruby -e 'puts STDIN.readlines.reverse!.slice(0,10).reverse!'

# print the last 2 lines of a file (emulate 'tail -2'); NOTE reads entire file!
    $ cat <file> | ruby -e 'puts STDIN.readlines.reverse!.slice(0,2).reverse!'

# print the last line of a file (emulates 'tail -1')
    $ cat <file> | ruby -ne 'line = $_; END {puts line}'

# print only lines that match a regular expression (emulates 'grep')
    $ cat <file> | ruby -pe 'next unless $_ =~ /regexp/'

# print only lines that DO NOT match a regular expression (emulates 'grep')
    $ cat <file> | ruby -pe 'next if $_ =~ /regexp/'

# print the line immediately before a regexp, but not the regex matching line
    $ cat <file> | ruby -ne 'puts @prev if $_ =~ /regex/; @prev = $_;'

# print the line immediately after a regexp, but not the regex matching line
    $ cat <file> | ruby -ne 'puts $_ if @prev =~ /regex/; @prev = $_;'

# grep for foo AND bar AND baz (in any order)
    $ cat <file> | ruby -pe 'next unless $_ =~ /foo/ && $_ =~ /bar/ && $_ =~ /baz/'

# grep for foo AND bar AND baz (in order)
    $ cat <file> | ruby -pe 'next unless $_ =~ /foo.*bar.*baz/'

# grep for foo OR bar OR baz
    $ cat <file> | ruby -pe 'next unless $_ =~ /(foo|bar|baz)/'

# print paragraph if it contains regexp; blank lines separate paragraphs
    $ cat <file> | ruby -ne 'BEGIN{$/="\n\n"}; print $_ if $_ =~ /regexp/'

# print paragraph if it contains foo AND bar AND baz (in any order); blank lines separate paragraphs
    $ cat <file> | ruby -ne 'BEGIN{$/="\n\n"}; print $_ if $_ =~ /foo/ && $_ =~ /bar/ && $_ =~ /baz/'

# print paragraph if it contains foo AND bar AND baz (in order); blank lines separate paragraphs
    $ cat <file> | ruby -ne 'BEGIN{$/="\n\n"}; print $_ if $_ =~ /(foo.*bar.*baz)/'

# print paragraph if it contains foo OR bar OR baz; blank lines separate paragraphs
    $ cat <file> | ruby -ne 'BEGIN{$/="\n\n"}; print $_ if $_ =~ /(foo|bar|baz)/'

# print only lines of 65 characters or greater
    $ cat <file> | ruby -pe 'next unless $_.chomp.length >= 65'
    $ cat <file> | ruby -lpe 'next unless $_.length >= 65'

# print only lines of 65 characters or less
    $ cat <file> | ruby -pe 'next unless $_.chomp.length < 65'
    $ cat <file> | ruby -lpe 'next unless $_.length < 65'

# print section of file from regex to end of file
    $ cat <file> | ruby -pe '@found=true if $_ =~ /regex/; next unless @found'

# print section of file based on line numbers (eg. lines 2-7 inclusive)
    $ cat <file> | ruby -pe 'next unless $. >= 2 && $. <= 7'

# print line number 52
    $ cat <file> | ruby -pe 'next unless $. == 52'

# print every 3rd line starting at line 4
    $ cat <file> | ruby -pe 'next unless $. >= 4 && $. % 3 == 0'

# print section of file between two regular expressions, /foo/ and /bar/
    $ cat <file> | ruby -ne '@found=true if $_ =~ /foo/; next unless @found; puts $_; exit if $_ =~ /bar/'


# SELECTIVE DELETION OF CERTAIN LINES

# print all of file except between two regular expressions, /foo/ and /bar/
    $ cat <file> | ruby -ne '@found = true if $_ =~ /foo/; puts $_ unless @found; @found = false if $_ =~ /bar/'

# print file and remove duplicate, consecutive lines from a file (emulates 'uniq')
    $ cat <file> | ruby -ne 'puts $_ unless $_ == @prev; @prev = $_'

# print file and remove duplicate, non-consecutive lines from a file (careful of memory!)
    $ cat <file> | ruby -e 'puts STDIN.readlines.sort.uniq!.to_s'

# print file except for first 10 lines
    $ cat <file> | ruby -pe 'next if $. <= 10'

# print file except for last line
    $ cat <file> | ruby -e 'lines=STDIN.readlines; puts lines[0,lines.size-1]'

# print file except for last 2 lines
    $ cat <file> | ruby -e 'lines=STDIN.readlines; puts lines[0,lines.size-2]'

# print file except for last 10 lines
    $ cat <file> | ruby -e 'lines=STDIN.readlines; puts lines[0,lines.size-10]'

# print file except for every 8th line
    $ cat <file> | ruby -pe 'next if $. % 8 == 0'

# print file except for blank lines
    $ cat <file> | ruby -pe 'next if $_ =~ /^\s*$/'

# delete all consecutive blank lines from a file except the first
    $ cat <file>  | ruby -e 'BEGIN{$/=nil}; puts STDIN.readlines.to_s.gsub(/\n(\n)+/, "\n\n")'

# delete all consecutive blank lines from a file except for the first 2
    $ cat <file>  | ruby -e 'BEGIN{$/=nil}; puts STDIN.readlines.to_s.gsub(/\n(\n)+/, "\n\n")'

# delete all leading blank lines at top of file
    $ cat <file> | ruby -pe '@lineFound = true if $_ !~ /^\s*$/; next if !@lineFound'



################################################################
######################### some oneliner ########################
################################################################

a.scan(/(.{1,150})/).join("\n")

require 'date'; Date.parse('June 12 2005').year

3.times { p 'duck'*3+"ing on Ruby's door!"}; p 'O'+'h'*4+' yeah'+'!'*4

IO.popen ("which ruby") { |f| p f.gets }
output = IO.popen("which ruby").readlines
output = %x{which ruby}
output = `which ruby`
system("which ruby") # only true|false


"(1,2,3,4,5)".slice(1..-2).split(',')

logger.debug("My object is " + obj + ". Cool!") if logger.debug?

fl = 79.4788888; sprintf("%.3f", fl).to_f
(79.478888 * 1000).round.to_f / 1000

c = a.merge!(b) { |key, old_value, new_value| old_value + new_value }

FileTest.directory?("folder") # true|false
File.exists?("file_or_folder") # true|false

directories, files = Dir['*'].partition{|d| File.directory? d}

def a(&a);yield(a,10);end;a{|a,i|(i==1)?(print "los gehts!\n"):(print "#{i-=1}...";a.call(a,i))}

if s.count('.') == 1 #check if a string contains only one (not more) dot?

ruby -e "puts 'nil brei'.unpack('x6a2X8ax2axa2X3axaX5aXa').to_s"

puts "Parent is #{Process.pid}"

"I like Ruby!".split("").each{|c|print c;$>.flush;sleep(0.05)}

((:janfri.to_s*2).to_i(36)+'8joj609n02kw'.to_i(36)).to_s(36).tr!('x',' ').capitalize!

require 'md5'; MD5.new('foo').hexdigest

'nil brei'.unpack('x6a2X8ax2axa2X3axaX5aXa').to_s

item.employee.full_name unless item.employee.nil?
"anyone" if item.employee.nil?

"aa, bb,cc,  dd".split(',').collect! { |x| x.strip }

def local_ip 
  ifconfig = %x(which /sbin/ifconfig).strip 
  %x(ifconfig).split("lo").shift =~ /inet addr\:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/ 
  $1 
end

require 'Mp3Info'
Dir['**.[mM][pP]3'].each do |mp3|
  Mp3Info.open(mp3) do |id3|
    print mp3, "\n"
    print "Artist: ", id3.tag.artist, "\n"
    print "Title: ", id3.tag.title, "\n"
    print "Album: ", id3.tag.album, "\n\n"
  end
end

"#{x/3600}:#{x/60%60}:#{x%60}" # x seconds into time..

"thisIsCamelCase".gsub(/[A-Z]/) {|match| "_#{match.downcase}" }