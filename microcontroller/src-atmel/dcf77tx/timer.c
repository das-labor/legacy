// Timerroutinen// generiert einen Software 32-Bit Timer, der // mit 450 Hz (2,222..ms) @ 7.372800 Mhz "tickt".// Dazu wird der 8-Bit Hardwaretimer Timer0 verwendet.#include <avr/io.h>#include <avr/interrupt.h>#include "hardware.h"#include "timer.h"// Initialisiert das Timersystemvoid timer_init( void ){	// Timer0- und Output-Compare0 Interrupt abschalten	TIMSK &= ~(_BV(TOIE0)); // | _BV(OCIE0));	timer_value = (unsigned long)0;	// Softwaretimer auf 0 setzen	#if defined(__AVR_ATmega128__) 		TCCR0 = _BV(CS02);  	#else		TCCR0 = _BV(CS01) | _BV(CS00);	// clkIO/64 (From prescaler) => 450 Hz @ 7.372800 Mhz  	#endif	TCNT0 = 0;				// Hardwaretimer auf 0 setzen	TIFR |= _BV(TOV0);		// Timer0-Interruptflag löschen	TIMSK |= _BV(TOIE0);	// Timer0-Interrupt aktivieren}/* Gibt die Zeitdifferenz zwischen zwei Timestamps zurück * Der zweite Wert sollte immer der vom späteren Zeitpunkt sein. * Ansonsten erhält man einen sehr großen falschen Wert. * Wenn aber der Timer zwischen den zwei Zeitpunkten * Übergelaufen ist, kommt trotzdem die richtige Zeitdifferenz herraus!	 */ inline unsigned long timer_diff_time( unsigned long first_timepoint, unsigned long second_timepoint){  return( second_timepoint - first_timepoint );}/*  Gibt true zurück, wenn die übergebene Zeit abgelaufen ist.  *  Es muss ein auf 0 initialisiertes Handle übergeben werden. *  Wenn true zurückgegeben wird, wird auch das Handle wieder auf 0 (=ungültig) gesetzt. *  Wenn die Funktion auf ein ungültiges Handle trifft, wird in dieses die aktuelle Zeit gespeichert *  und false zurück gegeben. So kann die Funktion immer wieder aufgerufen werden, ohne das das *  Handle neu initialisiert werden muss.	 */unsigned char timer_autodelay(unsigned long *handle, unsigned long time){	unsigned char retval=0;	if(!handle) return(0);
	if(*handle) {	    // Zeit abgelaufen?		if(timer_elapsed_time(*handle)>time) {			retval=!0;			*handle = 0;		}	} else {		// Handle ungültig, Zeitstempel ins Handle schreiben		*handle = timer_getvalue();		// Für eine sehr seltene, aber mögliche Fehlersituation...		if(!(*handle)) *handle++;	}	return(retval);}// EOF
