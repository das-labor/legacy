   1               		.file	"MessageTimers.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  80               	.global	switcherTcb
  81               		.section	.progmem.data,"a",@progbits
  84               	switcherTcb:
  85 0000 0000      		.word	switcherStk+44
  86 0002 0000      		.word	pm(switcher)
  87 0004 0000      		.word	switcherPid
  88 0006 03        		.byte	3
  89               	.global	flasherTcb
  92               	flasherTcb:
  93 0007 0000      		.word	flasherStk+54
  94 0009 0000      		.word	pm(flasher)
  95 000b 0000      		.word	flasherPid
  96 000d 02        		.byte	2
  97               	.global	MonitorTcb
 100               	MonitorTcb:
 101 000e 0000      		.word	MonitorStk+54
 102 0010 0000      		.word	pm(Monitor)
 103 0012 0000      		.word	MonitorPid
 104 0014 00        		.byte	0
 105               		.text
 107               	.global	__vector_11
 109               	__vector_11:
   1:MessageTimers.c **** /*
   2:MessageTimers.c ****     Timer Message Example
   3:MessageTimers.c **** 
   4:MessageTimers.c ****     This example shows:
   5:MessageTimers.c **** 
   6:MessageTimers.c ****     1. A task that waits on a message queue for information or a timeout.
   7:MessageTimers.c ****     2. Shows how to build messages that contain data
   8:MessageTimers.c ****     3. Shows how to include the AvrX Debug monitor
   9:MessageTimers.c **** 
  10:MessageTimers.c ****     The task "Switcher" examines the state of the STK switches, connected to
  11:MessageTimers.c ****     the port defined in "hardware.h" on a 10ms interval.  When the state of
  12:MessageTimers.c ****     the switches change, it sends a message to the second task with the
  13:MessageTimers.c ****     current switch state
  14:MessageTimers.c **** 
  15:MessageTimers.c ****     The second task "Flasher", starts a special timer that send's itself as a
  16:MessageTimers.c ****     message to a message queue when it expires.  The task waits on the
  17:MessageTimers.c ****     message queue for either the switch message or the timer message.
  18:MessageTimers.c **** 
  19:MessageTimers.c ****     Note: in this example I do not use AvrXCancelTimerMessage.  So the code
  20:MessageTimers.c ****     has been arranged so that the timer is restarted only after it has expired
  21:MessageTimers.c ****     and been read off the message queue.
  22:MessageTimers.c **** 
  23:MessageTimers.c ****     This example also show how to wire in the debug monitor for AvrX.  If the
  24:MessageTimers.c ****     kernel library has been compiled with the symbol SINGLESTEPSUPPORT defined
  25:MessageTimers.c ****     the monitor will allow you to halt a task and single step it through the
  26:MessageTimers.c ****     code
  27:MessageTimers.c **** 
  28:MessageTimers.c ****     To remove the monitor code, comment out the AVRX_TASK() definition, the
  29:MessageTimers.c ****     call AvrXRunTask and the call to InitSerialIO();
  30:MessageTimers.c **** */
  31:MessageTimers.c **** //#define ENABLE_BIT_DEFINITIONS
  32:MessageTimers.c **** //#define _SFR_ASM_COMPAT 1
  33:MessageTimers.c **** #include <avrx-io.h>
  34:MessageTimers.c **** #include <avrx-signal.h>
  35:MessageTimers.c **** #include "avrx.h"               // AvrX System calls/data structures
  36:MessageTimers.c **** #include "serialio.h"           // From AvrX...
  37:MessageTimers.c **** #include "hardware.h"           // Sample code hardware defines
  38:MessageTimers.c **** 
  39:MessageTimers.c **** // Declare all my AvrX data structures
  40:MessageTimers.c **** 
  41:MessageTimers.c **** AVRX_IAR_TASK(Monitor, 0, 20, 0);       // External Task: Debug Monitor
  42:MessageTimers.c **** AVRX_GCC_TASK(Monitor, 20, 0);          // External Task: Debug Monitor
  43:MessageTimers.c **** 
  44:MessageTimers.c **** TimerControlBlock SwTimer;      // Plain vanilla timer
  45:MessageTimers.c **** TimerMessageBlock Timer;        // TimerMessage timer (just a timer with a
  46:MessageTimers.c ****                                 // message queue pointer appended)
  47:MessageTimers.c **** 
  48:MessageTimers.c **** // This is how you build up a message element that transports data
  49:MessageTimers.c **** 
  50:MessageTimers.c **** typedef struct MyMessage
  51:MessageTimers.c **** {
  52:MessageTimers.c ****     MessageControlBlock mcb;
  53:MessageTimers.c ****     unsigned char data;
  54:MessageTimers.c **** }
  55:MessageTimers.c **** *pMyMessage, MyMessage;
  56:MessageTimers.c **** 
  57:MessageTimers.c **** MyMessage SwitchMsg;            // Declare the actual message
  58:MessageTimers.c **** MessageQueue MyQueue;           // The message queue itself
  59:MessageTimers.c **** 
  60:MessageTimers.c **** /*
  61:MessageTimers.c ****     Tasks and AvrX Interrupt handlers exist in their own context (registers
  62:MessageTimers.c ****     & stack) hence don't need to save anything and never return, hence "naked"
  63:MessageTimers.c **** */
  64:MessageTimers.c **** #pragma optimize=z 4
  65:MessageTimers.c **** AVRX_SIGINT(SIG_OVERFLOW0)
  66:MessageTimers.c **** {
 111               	.LM1:
 112               	/* prologue: frame size=0 */
 113               	/* prologue: naked */
 114               	/* prologue end (size=0) */
  67:MessageTimers.c ****     IntProlog();                // Save interrupted context, switch stacks
 116               	.LM2:
 117 0000 0E94 0000 		call IntProlog
  68:MessageTimers.c ****     TCNT0 = TCNT0_INIT;
 119               	.LM3:
 120 0004 81EC      		ldi r24,lo8(-63)
 121 0006 82BF      		out 82-0x20,r24
  69:MessageTimers.c **** //    outp(TCNT0_INIT, TCNT0);    // Reload the timer counter
  70:MessageTimers.c ****     AvrXTimerHandler();         // Process Timer queue
 123               	.LM4:
 124 0008 0E94 0000 		call AvrXTimerHandler
  71:MessageTimers.c ****     Epilog();                   // Restore context of next running task
 126               	.LM5:
 127 000c 0E94 0000 		call Epilog
 128               	/* epilogue: frame size=0 */
 129               	/* epilogue: naked */
 130               	/* epilogue end (size=0) */
 131               	/* function __vector_11 size 8 (8) */
 133               	.Lscope0:
 135               	.global	flasher
 137               	flasher:
  72:MessageTimers.c **** }
  73:MessageTimers.c **** 
  74:MessageTimers.c **** 
  75:MessageTimers.c **** AVRX_IAR_TASKDEF(flasher, 4, 16, 2)
  76:MessageTimers.c **** AVRX_GCC_TASKDEF(flasher, 20, 2)    // Note I added r_stack and c_stack!
  77:MessageTimers.c **** {
 139               	.LM6:
 140               	/* prologue: frame size=0 */
 141               	/* prologue end (size=0) */
  78:MessageTimers.c ****     pMyMessage pMsg;
  79:MessageTimers.c ****     unsigned char led = 0;
 143               	.LM7:
 144 0010 C0E0      		ldi r28,lo8(0)
  80:MessageTimers.c **** 
  81:MessageTimers.c **** 	LEDDDR = 0xFF;
 146               	.LM8:
 147 0012 8FEF      		ldi r24,lo8(-1)
 148 0014 84BB      		out 52-0x20,r24
 149               	.L14:
  82:MessageTimers.c **** //    outp(0xFF, LEDDDR);         // Initialize LED port to outputs
  83:MessageTimers.c **** 
  84:MessageTimers.c ****     AvrXStartTimerMessage(&Timer, 150, &MyQueue);
 151               	.LM9:
 152 0016 40E0      		ldi r20,lo8(MyQueue)
 153 0018 50E0      		ldi r21,hi8(MyQueue)
 154 001a 66E9      		ldi r22,lo8(150)
 155 001c 70E0      		ldi r23,hi8(150)
 156 001e 80E0      		ldi r24,lo8(Timer)
 157 0020 90E0      		ldi r25,hi8(Timer)
 158 0022 0E94 0000 		call AvrXStartTimerMessage
 159               	.L15:
  85:MessageTimers.c **** 
  86:MessageTimers.c ****     while(1)
  87:MessageTimers.c ****     {
  88:MessageTimers.c ****     	LED = ~led;
 161               	.LM10:
 162 0026 8C2F      		mov r24,r28
 163 0028 8095      		com r24
 164 002a 85BB      		out 53-0x20,r24
  89:MessageTimers.c **** //	    outp(~led, LED);
  90:MessageTimers.c ****         pMsg = (pMyMessage)AvrXWaitMessage(&MyQueue);
 166               	.LM11:
 167 002c 80E0      		ldi r24,lo8(MyQueue)
 168 002e 90E0      		ldi r25,hi8(MyQueue)
 169 0030 0E94 0000 		call AvrXWaitMessage
 170 0034 9C01      		movw r18,r24
  91:MessageTimers.c ****         if (pMsg == &SwitchMsg)
 172               	.LM12:
 173 0036 80E0      		ldi r24,hi8(SwitchMsg)
 174 0038 2030      		cpi r18,lo8(SwitchMsg)
 175 003a 3807      		cpc r19,r24
 176 003c 41F4      		brne .L5
  92:MessageTimers.c ****         {
  93:MessageTimers.c ****             led ^= ~(pMsg->data);
 178               	.LM13:
 179 003e 8091 0000 		lds r24,SwitchMsg+4
 180 0042 8095      		com r24
 181 0044 C827      		eor r28,r24
  94:MessageTimers.c ****             AvrXAckMessage(&pMsg->mcb);
 183               	.LM14:
 184 0046 C901      		movw r24,r18
 185 0048 0E94 0000 		call AvrXAckMessage
 186 004c ECCF      		rjmp .L15
 187               	.L5:
  95:MessageTimers.c ****         }
  96:MessageTimers.c ****         else if ((pTimerMessageBlock)pMsg == &Timer)
 189               	.LM15:
 190 004e 2050      		subi r18,lo8(Timer)
 191 0050 3040      		sbci r19,hi8(Timer)
 192 0052 21F4      		brne .L7
  97:MessageTimers.c ****         {
  98:MessageTimers.c **** #ifdef __IAR_SYSTEMS_ICC__
  99:MessageTimers.c ****             led = led+led+((led & 0x80)?1:0);
 100:MessageTimers.c **** #else
 101:MessageTimers.c ****             asm("rol %0\n"\
 194               	.LM16:
 195               	/* #APP */
 196 0054 CC1F      		rol r28
 197 0056 08F4      		brcc .+2
 198 0058 C395      		inc r28
 199               	
 200               	/* #NOAPP */
 201 005a DDCF      		rjmp .L14
 202               	.L7:
 102:MessageTimers.c ****                 "\tbrcc .+2\n"\
 103:MessageTimers.c ****                 "\tinc %0\n"  ::"r" (led));
 104:MessageTimers.c **** #endif
 105:MessageTimers.c ****             AvrXStartTimerMessage(&Timer, 150, &MyQueue);
 106:MessageTimers.c ****         }
 107:MessageTimers.c ****         else
 108:MessageTimers.c ****         {
 109:MessageTimers.c ****             AvrXHalt();
 204               	.LM17:
 205 005c 0E94 0000 		call AvrXHalt
 206 0060 E2CF      		rjmp .L15
 207               	/* epilogue: frame size=0 */
 208               	/* epilogue: noreturn */
 209               	/* epilogue end (size=0) */
 210               	/* function flasher size 47 (47) */
 216               	.Lscope1:
 218               	.global	switcher
 220               	switcher:
 110:MessageTimers.c ****         }
 111:MessageTimers.c ****     }
 112:MessageTimers.c **** }
 113:MessageTimers.c **** 
 114:MessageTimers.c **** AVRX_IAR_TASKDEF(switcher, 4, 6, 3)
 115:MessageTimers.c **** AVRX_GCC_TASKDEF(switcher, 10, 3)
 116:MessageTimers.c **** {
 222               	.LM18:
 223               	/* prologue: frame size=0 */
 224               	/* prologue end (size=0) */
 117:MessageTimers.c **** 	SWITCHP = 0xFF;
 226               	.LM19:
 227 0062 8FEF      		ldi r24,lo8(-1)
 228 0064 88BB      		out 56-0x20,r24
 229               	.L23:
 118:MessageTimers.c **** //    outp(0xFF, SWITCHP);            // Enable pullups on switch inputs
 119:MessageTimers.c ****     while(1)
 120:MessageTimers.c ****     {
 121:MessageTimers.c ****         AvrXDelay(&SwTimer, 10);        // Delay 10 milliseconds
 231               	.LM20:
 232 0066 6AE0      		ldi r22,lo8(10)
 233 0068 70E0      		ldi r23,hi8(10)
 234 006a 80E0      		ldi r24,lo8(SwTimer)
 235 006c 90E0      		ldi r25,hi8(SwTimer)
 236 006e 0E94 0000 		call AvrXDelay
 122:MessageTimers.c **** //        if (SwitchMsg.data != inp(SWITCH)) // On change, send message
 123:MessageTimers.c ****         if (SwitchMsg.data != SWITCH) // On change, send message
 238               	.LM21:
 239 0072 9091 0000 		lds r25,SwitchMsg+4
 240 0076 86B3      		in r24,54-0x20
 241 0078 9817      		cp r25,r24
 242 007a A9F3      		breq .L23
 124:MessageTimers.c ****         {
 125:MessageTimers.c **** //            SwitchMsg.data = inp(SWITCH);
 126:MessageTimers.c ****             SwitchMsg.data = SWITCH;
 244               	.LM22:
 245 007c 86B3      		in r24,54-0x20
 246 007e 8093 0000 		sts SwitchMsg+4,r24
 127:MessageTimers.c ****             AvrXSendMessage(&MyQueue, &SwitchMsg.mcb);
 248               	.LM23:
 249 0082 60E0      		ldi r22,lo8(SwitchMsg)
 250 0084 70E0      		ldi r23,hi8(SwitchMsg)
 251 0086 80E0      		ldi r24,lo8(MyQueue)
 252 0088 90E0      		ldi r25,hi8(MyQueue)
 253 008a 0E94 0000 		call AvrXSendMessage
 128:MessageTimers.c ****             AvrXWaitMessageAck(&SwitchMsg.mcb);
 255               	.LM24:
 256 008e 80E0      		ldi r24,lo8(SwitchMsg)
 257 0090 90E0      		ldi r25,hi8(SwitchMsg)
 258 0092 0E94 0000 		call AvrXWaitMessageAck
 259 0096 E7CF      		rjmp .L23
 260               	/* epilogue: frame size=0 */
 261               	/* epilogue: noreturn */
 262               	/* epilogue end (size=0) */
 263               	/* function switcher size 27 (27) */
 265               	.Lscope2:
 267               	.global	main
 269               	main:
 129:MessageTimers.c ****         }
 130:MessageTimers.c ****     }
 131:MessageTimers.c **** }
 132:MessageTimers.c **** 
 133:MessageTimers.c **** int main(void)
 134:MessageTimers.c **** {
 271               	.LM25:
 272               	/* prologue: frame size=0 */
 273 0098 C0E0      		ldi r28,lo8(__stack - 0)
 274 009a D0E0      		ldi r29,hi8(__stack - 0)
 275 009c DEBF      		out __SP_H__,r29
 276 009e CDBF      		out __SP_L__,r28
 277               	/* prologue end (size=4) */
 135:MessageTimers.c ****     AvrXSetKernelStack(0);
 279               	.LM26:
 280 00a0 80E0      		ldi r24,lo8(0)
 281 00a2 90E0      		ldi r25,hi8(0)
 282 00a4 0E94 0000 		call AvrXSetKernelStack
 136:MessageTimers.c **** 
 137:MessageTimers.c ****     MCUCR = 1<<SE;
 284               	.LM27:
 285 00a8 80E8      		ldi r24,lo8(-128)
 286 00aa 85BF      		out 85-0x20,r24
 138:MessageTimers.c ****     TCNT0 = TCNT0_INIT;
 288               	.LM28:
 289 00ac 81EC      		ldi r24,lo8(-63)
 290 00ae 82BF      		out 82-0x20,r24
 139:MessageTimers.c ****     TCCR0 = TMC8_CK256;
 292               	.LM29:
 293 00b0 84E0      		ldi r24,lo8(4)
 294 00b2 83BF      		out 83-0x20,r24
 140:MessageTimers.c ****     TIMSK = 1<<TOIE0;
 296               	.LM30:
 297 00b4 81E0      		ldi r24,lo8(1)
 298 00b6 89BF      		out 89-0x20,r24
 141:MessageTimers.c **** /*
 142:MessageTimers.c ****     outp((1<<SE) , MCUCR);      // Enable "sleep" mode (low power when idle)
 143:MessageTimers.c ****     outp(TCNT0_INIT, TCNT0);    // Load overflow counter of timer0
 144:MessageTimers.c ****     outp(TMC8_CK256 , TCCR0);   // Set Timer0 to CPUCLK/256
 145:MessageTimers.c ****     outp((1<<TOIE0), TIMSK);    // Enable interrupt flag
 146:MessageTimers.c **** */
 147:MessageTimers.c ****     InitSerialIO(UBRR_INIT);    // Initialize USART baud rate generator
 300               	.LM31:
 301 00b8 83E3      		ldi r24,lo8(51)
 302 00ba 90E0      		ldi r25,hi8(51)
 303 00bc 0E94 0000 		call InitSerialIO
 148:MessageTimers.c **** 
 149:MessageTimers.c ****     AvrXRunTask(TCB(flasher));
 305               	.LM32:
 306 00c0 80E0      		ldi r24,lo8(flasherTcb)
 307 00c2 90E0      		ldi r25,hi8(flasherTcb)
 308 00c4 0E94 0000 		call AvrXRunTask
 150:MessageTimers.c ****     AvrXRunTask(TCB(switcher));
 310               	.LM33:
 311 00c8 80E0      		ldi r24,lo8(switcherTcb)
 312 00ca 90E0      		ldi r25,hi8(switcherTcb)
 313 00cc 0E94 0000 		call AvrXRunTask
 151:MessageTimers.c ****     AvrXRunTask(TCB(Monitor));
 315               	.LM34:
 316 00d0 80E0      		ldi r24,lo8(MonitorTcb)
 317 00d2 90E0      		ldi r25,hi8(MonitorTcb)
 318 00d4 0E94 0000 		call AvrXRunTask
 152:MessageTimers.c **** 
 153:MessageTimers.c ****     /* Needed for EEPROM access in monitor */
 154:MessageTimers.c **** 
 155:MessageTimers.c ****     AvrXSetSemaphore(&EEPromMutex);
 320               	.LM35:
 321 00d8 80E0      		ldi r24,lo8(EEPromMutex)
 322 00da 90E0      		ldi r25,hi8(EEPromMutex)
 323 00dc 0E94 0000 		call AvrXSetSemaphore
 156:MessageTimers.c **** 
 157:MessageTimers.c ****     Epilog();                   // Switch from AvrX Stack to first task
 325               	.LM36:
 326 00e0 0E94 0000 		call Epilog
 327               	.L25:
 158:MessageTimers.c ****     while(1);
 329               	.LM37:
 330 00e4 FFCF      		rjmp .L25
 331               	/* epilogue: frame size=0 */
 332               	/* epilogue: noreturn */
 333               	/* epilogue end (size=0) */
 334               	/* function main size 39 (35) */
 336               	.Lscope3:
 337               		.comm MonitorStk,55,1
 338               		.comm MonitorPid,6,1
 339               		.comm SwTimer,6,1
 340               		.comm Timer,8,1
 341               		.comm SwitchMsg,5,1
 342               		.comm MyQueue,4,1
 343               		.comm flasherStk,55,1
 344               		.comm flasherPid,6,1
 345               		.comm switcherStk,45,1
 346               		.comm switcherPid,6,1
 360               		.text
 362               	Letext:
 363               	/* File "MessageTimers.c": code  121 = 0x0079 ( 117), prologues   4, epilogues   0 */
DEFINED SYMBOLS
                            *ABS*:00000000 MessageTimers.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
     /tmp/ccaFoCxK.s:84     .progmem.data:00000000 switcherTcb
                            *COM*:0000002d switcherStk
     /tmp/ccaFoCxK.s:220    .text:00000062 switcher
                            *COM*:00000006 switcherPid
     /tmp/ccaFoCxK.s:92     .progmem.data:00000007 flasherTcb
                            *COM*:00000037 flasherStk
     /tmp/ccaFoCxK.s:137    .text:00000010 flasher
                            *COM*:00000006 flasherPid
     /tmp/ccaFoCxK.s:100    .progmem.data:0000000e MonitorTcb
                            *COM*:00000037 MonitorStk
                            *COM*:00000006 MonitorPid
     /tmp/ccaFoCxK.s:109    .text:00000000 __vector_11
                            *COM*:00000004 MyQueue
                            *COM*:00000008 Timer
                            *COM*:00000005 SwitchMsg
                            *COM*:00000006 SwTimer
     /tmp/ccaFoCxK.s:269    .text:00000098 main
     /tmp/ccaFoCxK.s:362    .text:000000e6 Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
Monitor
IntProlog
AvrXTimerHandler
Epilog
AvrXStartTimerMessage
AvrXWaitMessage
AvrXAckMessage
AvrXHalt
AvrXDelay
AvrXSendMessage
AvrXWaitMessageAck
__stack
AvrXSetKernelStack
InitSerialIO
AvrXRunTask
EEPromMutex
AvrXSetSemaphore
