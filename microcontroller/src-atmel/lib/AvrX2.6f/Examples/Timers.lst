   1               		.file	"Timers.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  93               	.global	task2Tcb
  94               		.section	.progmem.data,"a",@progbits
  97               	task2Tcb:
  98 0000 0000      		.word	task2Stk+42
  99 0002 0000      		.word	pm(task2)
 100 0004 0000      		.word	task2Pid
 101 0006 02        		.byte	2
 102               	.global	task1Tcb
 105               	task1Tcb:
 106 0007 0000      		.word	task1Stk+42
 107 0009 0000      		.word	pm(task1)
 108 000b 0000      		.word	task1Pid
 109 000d 03        		.byte	3
 110               	.global	MonitorTcb
 113               	MonitorTcb:
 114 000e 0000      		.word	MonitorStk+54
 115 0010 0000      		.word	pm(Monitor)
 116 0012 0000      		.word	MonitorPid
 117 0014 00        		.byte	0
 118               		.text
 120               	.global	__vector_11
 122               	__vector_11:
   1:Timers.c      **** /*
   2:Timers.c      **** 	Example code for setting up and using timers
   3:Timers.c      **** 
   4:Timers.c      **** 	Two tasks each waiting on a timer, flashing LED's on
   5:Timers.c      **** 	the evaluation board.  See "hardware.h" for LED definitions
   6:Timers.c      **** 
   7:Timers.c      ****     The kernel Stack is defined by the IAR linker file, or Top or SRAM
   8:Timers.c      ****     in GCC (can be altered in the GCC link files, or defined symbol)
   9:Timers.c      **** */
  10:Timers.c      **** //#define _SFR_ASM_COMPAT 1
  11:Timers.c      **** #include <avrx-io.h>
  12:Timers.c      **** #include <avrx-signal.h>
  13:Timers.c      **** 
  14:Timers.c      **** #include <avr/pgmspace.h>
  15:Timers.c      **** 
  16:Timers.c      **** #include "avrx.h"
  17:Timers.c      **** #include "serialio.h"       // From AvrX...
  18:Timers.c      **** #include "hardware.h"
  19:Timers.c      **** 
  20:Timers.c      **** AVRX_IAR_TASK(Monitor, 0, 20, 0);       // External Task: Debug Monitor
  21:Timers.c      **** AVRX_GCC_TASK(Monitor, 20, 0);          // External Task: Debug Monitor
  22:Timers.c      **** 
  23:Timers.c      **** TimerControlBlock   timer1,             // Declare the control blocks needed for timers
  24:Timers.c      ****                     timer2;
  25:Timers.c      **** /*
  26:Timers.c      ****  Timer 0 Overflow Interrupt Handler
  27:Timers.c      **** 
  28:Timers.c      ****  Prototypical Interrupt handler:
  29:Timers.c      ****  . Switch to kernel context
  30:Timers.c      ****  . handle interrupt
  31:Timers.c      ****  . switch back to interrupted context.
  32:Timers.c      ****  */
  33:Timers.c      **** 
  34:Timers.c      **** #pragma optimize=z 4
  35:Timers.c      **** AVRX_SIGINT(SIG_OVERFLOW0)
  36:Timers.c      **** {
 124               	.LM1:
 125               	/* prologue: frame size=0 */
 126               	/* prologue: naked */
 127               	/* prologue end (size=0) */
  37:Timers.c      ****     IntProlog();                // Switch to kernel stack/context
 129               	.LM2:
 130 0000 0E94 0000 		call IntProlog
  38:Timers.c      ****     TCNT0 = TCNT0_INIT;
 132               	.LM3:
 133 0004 81EC      		ldi r24,lo8(-63)
 134 0006 82BF      		out 82-0x20,r24
  39:Timers.c      **** //    outp(TCNT0_INIT, TCNT0);
  40:Timers.c      ****     AvrXTimerHandler();         // Call Time queue manager
 136               	.LM4:
 137 0008 0E94 0000 		call AvrXTimerHandler
  41:Timers.c      ****     Epilog();                   // Return to tasks
 139               	.LM5:
 140 000c 0E94 0000 		call Epilog
 141               	/* epilogue: frame size=0 */
 142               	/* epilogue: naked */
 143               	/* epilogue end (size=0) */
 144               	/* function __vector_11 size 8 (8) */
 146               	.Lscope0:
 148               	.global	task1
 150               	task1:
  42:Timers.c      **** }
  43:Timers.c      **** 
  44:Timers.c      **** /*
  45:Timers.c      ****  Task 1 simply flashes the light off for 1/5 second and then on for 4/5th
  46:Timers.c      ****  for a 1 second cycle time.
  47:Timers.c      ****  */
  48:Timers.c      **** AVRX_IAR_TASKDEF(task1, 0, 6, 3)
  49:Timers.c      **** AVRX_GCC_TASKDEF(task1, 8, 3)
  50:Timers.c      **** {
 152               	.LM6:
 153               	/* prologue: frame size=0 */
 154               	/* prologue end (size=0) */
 155               	.L3:
  51:Timers.c      ****     while (1)
  52:Timers.c      ****     {
  53:Timers.c      ****         AvrXStartTimer(&timer1, 800);       // 800 ms delay
 157               	.LM7:
 158 0010 60E2      		ldi r22,lo8(800)
 159 0012 73E0      		ldi r23,hi8(800)
 160 0014 80E0      		ldi r24,lo8(timer1)
 161 0016 90E0      		ldi r25,hi8(timer1)
 162 0018 0E94 0000 		call AvrXStartTimer
  54:Timers.c      ****         AvrXWaitTimer(&timer1);
 164               	.LM8:
 165 001c 80E0      		ldi r24,lo8(timer1)
 166 001e 90E0      		ldi r25,hi8(timer1)
 167 0020 0E94 0000 		call AvrXWaitTimer
  55:Timers.c      ****         LED = LED ^ 0x01;
 169               	.LM9:
 170 0024 85B3      		in r24,53-0x20
 171 0026 11E0      		ldi r17,lo8(1)
 172 0028 8127      		eor r24,r17
 173 002a 85BB      		out 53-0x20,r24
  56:Timers.c      **** //        outp(inp(LED) ^ 0x01, LED);
  57:Timers.c      ****         AvrXStartTimer(&timer1, 200);       // 200 ms delay
 175               	.LM10:
 176 002c 68EC      		ldi r22,lo8(200)
 177 002e 70E0      		ldi r23,hi8(200)
 178 0030 80E0      		ldi r24,lo8(timer1)
 179 0032 90E0      		ldi r25,hi8(timer1)
 180 0034 0E94 0000 		call AvrXStartTimer
  58:Timers.c      ****         AvrXWaitTimer(&timer1);
 182               	.LM11:
 183 0038 80E0      		ldi r24,lo8(timer1)
 184 003a 90E0      		ldi r25,hi8(timer1)
 185 003c 0E94 0000 		call AvrXWaitTimer
  59:Timers.c      ****         LED = LED ^ 0x01;
 187               	.LM12:
 188 0040 85B3      		in r24,53-0x20
 189 0042 8127      		eor r24,r17
 190 0044 85BB      		out 53-0x20,r24
 191 0046 E4CF      		rjmp .L3
 192               	/* epilogue: frame size=0 */
 193               	/* epilogue: noreturn */
 194               	/* epilogue end (size=0) */
 195               	/* function task1 size 28 (28) */
 197               	.Lscope1:
 199               	.global	task2
 201               	task2:
  60:Timers.c      **** //        outp(inp(LED) ^ 0x01, LED);
  61:Timers.c      ****     }
  62:Timers.c      **** }
  63:Timers.c      **** /*
  64:Timers.c      ****  Task 2 cycles the light on/off over 4 seconds.  It uses a simplified
  65:Timers.c      ****  form of the delay API
  66:Timers.c      ****  */
  67:Timers.c      **** AVRX_IAR_TASKDEF(task2, 0, 6, 2)
  68:Timers.c      **** AVRX_GCC_TASKDEF(task2, 8, 2)
  69:Timers.c      **** {
 203               	.LM13:
 204               	/* prologue: frame size=0 */
 205               	/* prologue end (size=0) */
 206               	.L6:
  70:Timers.c      ****     while (1)
  71:Timers.c      ****     {
  72:Timers.c      ****         AvrXDelay(&timer2, 2000);           // 2 second delay
 208               	.LM14:
 209 0048 60ED      		ldi r22,lo8(2000)
 210 004a 77E0      		ldi r23,hi8(2000)
 211 004c 80E0      		ldi r24,lo8(timer2)
 212 004e 90E0      		ldi r25,hi8(timer2)
 213 0050 0E94 0000 		call AvrXDelay
  73:Timers.c      ****         LED = LED ^ 0x02;
 215               	.LM15:
 216 0054 85B3      		in r24,53-0x20
 217 0056 92E0      		ldi r25,lo8(2)
 218 0058 8927      		eor r24,r25
 219 005a 85BB      		out 53-0x20,r24
 220 005c F5CF      		rjmp .L6
 221               	/* epilogue: frame size=0 */
 222               	/* epilogue: noreturn */
 223               	/* epilogue end (size=0) */
 224               	/* function task2 size 11 (11) */
 226               	.Lscope2:
 228               	.global	main
 230               	main:
  74:Timers.c      **** //        outp((inp(LED) ^ 0x02), LED);
  75:Timers.c      ****     }
  76:Timers.c      **** }
  77:Timers.c      **** 
  78:Timers.c      **** int main(void)                 // Main runs under the AvrX Stack
  79:Timers.c      **** {
 232               	.LM16:
 233               	/* prologue: frame size=0 */
 234 005e C0E0      		ldi r28,lo8(__stack - 0)
 235 0060 D0E0      		ldi r29,hi8(__stack - 0)
 236 0062 DEBF      		out __SP_H__,r29
 237 0064 CDBF      		out __SP_L__,r28
 238               	/* prologue end (size=4) */
  80:Timers.c      ****     AvrXSetKernelStack(0);
 240               	.LM17:
 241 0066 80E0      		ldi r24,lo8(0)
 242 0068 90E0      		ldi r25,hi8(0)
 243 006a 0E94 0000 		call AvrXSetKernelStack
  81:Timers.c      **** /*
  82:Timers.c      ****     outp((1<<SE), MCUCR);       // Enable "Sleep" instruction
  83:Timers.c      ****     outp(TCNT0_INIT, TCNT0);
  84:Timers.c      ****     outp(TMC8_CK256, TCCR0);    // Set up Timer0 for CLK/256 rate
  85:Timers.c      ****     outp((1<<TOIE0), TIMSK);     // Enable Timer0 overflow interrupt
  86:Timers.c      **** 
  87:Timers.c      ****     outp(0xFF, LEDDDR);         // Make LED output and
  88:Timers.c      ****     outp(0xFF, LED);            // drive high (LEDs off)
  89:Timers.c      **** */
  90:Timers.c      ****     MCUCR = 1<<SE;
 245               	.LM18:
 246 006e 80E8      		ldi r24,lo8(-128)
 247 0070 85BF      		out 85-0x20,r24
  91:Timers.c      ****     TCNT0 = TCNT0_INIT;
 249               	.LM19:
 250 0072 81EC      		ldi r24,lo8(-63)
 251 0074 82BF      		out 82-0x20,r24
  92:Timers.c      ****     TCCR0 = TMC8_CK256;
 253               	.LM20:
 254 0076 84E0      		ldi r24,lo8(4)
 255 0078 83BF      		out 83-0x20,r24
  93:Timers.c      ****     TIMSK = 1<<TOIE0;
 257               	.LM21:
 258 007a 81E0      		ldi r24,lo8(1)
 259 007c 89BF      		out 89-0x20,r24
  94:Timers.c      **** 
  95:Timers.c      ****     LEDDDR = 0xFF;
 261               	.LM22:
 262 007e 8FEF      		ldi r24,lo8(-1)
 263 0080 84BB      		out 52-0x20,r24
  96:Timers.c      ****     LED   = 0xFF;
 265               	.LM23:
 266 0082 85BB      		out 53-0x20,r24
  97:Timers.c      **** 
  98:Timers.c      ****     AvrXRunTask(TCB(task1));
 268               	.LM24:
 269 0084 80E0      		ldi r24,lo8(task1Tcb)
 270 0086 90E0      		ldi r25,hi8(task1Tcb)
 271 0088 0E94 0000 		call AvrXRunTask
  99:Timers.c      ****     AvrXRunTask(TCB(task2));
 273               	.LM25:
 274 008c 80E0      		ldi r24,lo8(task2Tcb)
 275 008e 90E0      		ldi r25,hi8(task2Tcb)
 276 0090 0E94 0000 		call AvrXRunTask
 100:Timers.c      ****     AvrXRunTask(TCB(Monitor));
 278               	.LM26:
 279 0094 80E0      		ldi r24,lo8(MonitorTcb)
 280 0096 90E0      		ldi r25,hi8(MonitorTcb)
 281 0098 0E94 0000 		call AvrXRunTask
 101:Timers.c      **** 
 102:Timers.c      ****     InitSerialIO(UBRR_INIT);    // Initialize USART baud rate generator
 283               	.LM27:
 284 009c 83E3      		ldi r24,lo8(51)
 285 009e 90E0      		ldi r25,hi8(51)
 286 00a0 0E94 0000 		call InitSerialIO
 103:Timers.c      **** 	
 104:Timers.c      **** 	Epilog();                   // Switch from AvrX Stack to first task
 288               	.LM28:
 289 00a4 0E94 0000 		call Epilog
 290               	.L9:
 105:Timers.c      ****     while(1);
 292               	.LM29:
 293 00a8 FFCF      		rjmp .L9
 294               	/* epilogue: frame size=0 */
 295               	/* epilogue: noreturn */
 296               	/* epilogue end (size=0) */
 297               	/* function main size 38 (34) */
 299               	.Lscope3:
 300               		.comm MonitorStk,55,1
 301               		.comm MonitorPid,6,1
 302               		.comm timer1,6,1
 303               		.comm timer2,6,1
 304               		.comm task1Stk,43,1
 305               		.comm task1Pid,6,1
 306               		.comm task2Stk,43,1
 307               		.comm task2Pid,6,1
 319               		.text
 321               	Letext:
 322               	/* File "Timers.c": code   85 = 0x0055 (  81), prologues   4, epilogues   0 */
DEFINED SYMBOLS
                            *ABS*:00000000 Timers.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
     /tmp/ccmKmqaE.s:97     .progmem.data:00000000 task2Tcb
                            *COM*:0000002b task2Stk
     /tmp/ccmKmqaE.s:201    .text:00000048 task2
                            *COM*:00000006 task2Pid
     /tmp/ccmKmqaE.s:105    .progmem.data:00000007 task1Tcb
                            *COM*:0000002b task1Stk
     /tmp/ccmKmqaE.s:150    .text:00000010 task1
                            *COM*:00000006 task1Pid
     /tmp/ccmKmqaE.s:113    .progmem.data:0000000e MonitorTcb
                            *COM*:00000037 MonitorStk
                            *COM*:00000006 MonitorPid
     /tmp/ccmKmqaE.s:122    .text:00000000 __vector_11
                            *COM*:00000006 timer1
                            *COM*:00000006 timer2
     /tmp/ccmKmqaE.s:230    .text:0000005e main
     /tmp/ccmKmqaE.s:321    .text:000000aa Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
Monitor
IntProlog
AvrXTimerHandler
Epilog
AvrXStartTimer
AvrXWaitTimer
AvrXDelay
__stack
AvrXSetKernelStack
AvrXRunTask
InitSerialIO
