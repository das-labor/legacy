   1               		.file	"MessagesAndData.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  78               	.global	task2Tcb
  79               		.section	.progmem.data,"a",@progbits
  82               	task2Tcb:
  83 0000 0000      		.word	task2Stk+44
  84 0002 0000      		.word	pm(task2)
  85 0004 0000      		.word	task2Pid
  86 0006 03        		.byte	3
  87               	.global	task1Tcb
  90               	task1Tcb:
  91 0007 0000      		.word	task1Stk+44
  92 0009 0000      		.word	pm(task1)
  93 000b 0000      		.word	task1Pid
  94 000d 03        		.byte	3
  95               	.global	MonitorTcb
  98               	MonitorTcb:
  99 000e 0000      		.word	MonitorStk+54
 100 0010 0000      		.word	pm(Monitor)
 101 0012 0000      		.word	MonitorPid
 102 0014 00        		.byte	0
 103               		.text
 105               	.global	__vector_11
 107               	__vector_11:
   1:MessagesAndData.c **** /*
   2:MessagesAndData.c ****     Messages with data included example
   3:MessagesAndData.c **** 
   4:MessagesAndData.c ****     This example shows:
   5:MessagesAndData.c **** 
   6:MessagesAndData.c ****     1. How to extend the message queue element (MessageControlBlock)
   7:MessagesAndData.c ****         with data for passing between tasks
   8:MessagesAndData.c **** 
   9:MessagesAndData.c ****     2. Uses the AvrX macros to declare interrupt handlers and tasks
  10:MessagesAndData.c **** 
  11:MessagesAndData.c **** */
  12:MessagesAndData.c **** //#define ENABLE_BIT_DEFINITIONS
  13:MessagesAndData.c **** //#define _SFR_ASM_COMPAT 1
  14:MessagesAndData.c **** #include <avrx-io.h>
  15:MessagesAndData.c **** #include <avrx-signal.h>
  16:MessagesAndData.c **** #include "avrx.h"
  17:MessagesAndData.c **** #include "serialio.h"           // From AvrX...
  18:MessagesAndData.c **** #include "hardware.h"
  19:MessagesAndData.c **** 
  20:MessagesAndData.c **** AVRX_IAR_TASK(Monitor, 0, 20, 0);      // external Debug Monitor
  21:MessagesAndData.c **** AVRX_GCC_TASK(Monitor, 20, 0);      // external Debug Monitor
  22:MessagesAndData.c **** 
  23:MessagesAndData.c **** TimerControlBlock   MyTimer;    // Declare the control blocks needed for timers
  24:MessagesAndData.c **** 
  25:MessagesAndData.c **** typedef struct                  // Declare a new message type with data
  26:MessagesAndData.c **** {
  27:MessagesAndData.c ****     MessageControlBlock mcb;
  28:MessagesAndData.c ****     unsigned char         switches;
  29:MessagesAndData.c **** }
  30:MessagesAndData.c **** MyMessage;
  31:MessagesAndData.c **** 
  32:MessagesAndData.c **** MessageQueue        MyQueue;    // The message queue
  33:MessagesAndData.c **** 
  34:MessagesAndData.c **** /*
  35:MessagesAndData.c ****  Timer 0 Overflow Interrupt Handler
  36:MessagesAndData.c **** 
  37:MessagesAndData.c ****  This is a prototypical interrupt handler:
  38:MessagesAndData.c ****   . Switch to the AvrX kernel context - IntProlog()
  39:MessagesAndData.c ****   . Deal with the interrupt (the timer counter reload in this case)
  40:MessagesAndData.c ****   . return to the interrupted context - Epilog())
  41:MessagesAndData.c ****  */
  42:MessagesAndData.c **** #pragma optimize=z 4
  43:MessagesAndData.c **** AVRX_SIGINT(SIG_OVERFLOW0)
  44:MessagesAndData.c **** {
 109               	.LM1:
 110               	/* prologue: frame size=0 */
 111               	/* prologue: naked */
 112               	/* prologue end (size=0) */
  45:MessagesAndData.c ****     IntProlog();                // Switch to kernel stack/context
 114               	.LM2:
 115 0000 0E94 0000 		call IntProlog
  46:MessagesAndData.c ****     TCNT0 = TCNT0_INIT;
 117               	.LM3:
 118 0004 81EC      		ldi r24,lo8(-63)
 119 0006 82BF      		out 82-0x20,r24
  47:MessagesAndData.c **** //    outp(TCNT0_INIT, TCNT0);    // Reset timer overflow count
  48:MessagesAndData.c ****     AvrXTimerHandler();         // Call queue manager
 121               	.LM4:
 122 0008 0E94 0000 		call AvrXTimerHandler
  49:MessagesAndData.c ****     Epilog();                   // Return to tasks
 124               	.LM5:
 125 000c 0E94 0000 		call Epilog
 126               	/* epilogue: frame size=0 */
 127               	/* epilogue: naked */
 128               	/* epilogue end (size=0) */
 129               	/* function __vector_11 size 8 (8) */
 131               	.Lscope0:
 133               	.global	task1
 135               	task1:
  50:MessagesAndData.c **** }
  51:MessagesAndData.c **** /*
  52:MessagesAndData.c ****  Task 1 Waits for a message, then updates LED's with the contents.
  53:MessagesAndData.c ****  */
  54:MessagesAndData.c **** AVRX_IAR_TASKDEF(task1, 0, 10, 3)
  55:MessagesAndData.c **** AVRX_GCC_TASKDEF(task1, 10, 3)
  56:MessagesAndData.c **** {
 137               	.LM6:
 138               	/* prologue: frame size=0 */
 139               	/* prologue end (size=0) */
 140               	.L3:
  57:MessagesAndData.c ****     MessageControlBlock *p;
  58:MessagesAndData.c **** 
  59:MessagesAndData.c ****     while (1)
  60:MessagesAndData.c ****     {
  61:MessagesAndData.c ****         p = AvrXWaitMessage(&MyQueue);
 142               	.LM7:
 143 0010 80E0      		ldi r24,lo8(MyQueue)
 144 0012 90E0      		ldi r25,hi8(MyQueue)
 145 0014 0E94 0000 		call AvrXWaitMessage
 146 0018 FC01      		movw r30,r24
  62:MessagesAndData.c ****         LED = ((MyMessage*)p)->switches;
 148               	.LM8:
 149 001a 8481      		ldd r24,Z+4
 150 001c 85BB      		out 53-0x20,r24
  63:MessagesAndData.c **** //        outp(((MyMessage*)p)->switches, LED);
  64:MessagesAndData.c ****         AvrXAckMessage(p);
 152               	.LM9:
 153 001e CF01      		movw r24,r30
 154 0020 0E94 0000 		call AvrXAckMessage
 155 0024 F5CF      		rjmp .L3
 156               	/* epilogue: frame size=0 */
 157               	/* epilogue: noreturn */
 158               	/* epilogue end (size=0) */
 159               	/* function task1 size 11 (11) */
 164               	.Lscope1:
 165               		.lcomm SwitchMessage.0,5
 167               	.global	task2
 169               	task2:
  65:MessagesAndData.c ****     }
  66:MessagesAndData.c **** }
  67:MessagesAndData.c **** /*
  68:MessagesAndData.c ****  Task 2 Checks switches every 10ms and sends a message whenever SWITCH changes
  69:MessagesAndData.c ****  */
  70:MessagesAndData.c **** AVRX_IAR_TASKDEF(task2, 0, 10, 3)
  71:MessagesAndData.c **** AVRX_GCC_TASKDEF(task2, 10, 3)
  72:MessagesAndData.c **** {
 171               	.LM10:
 172               	/* prologue: frame size=0 */
 173               	/* prologue end (size=0) */
  73:MessagesAndData.c ****     static MyMessage SwitchMessage;
  74:MessagesAndData.c ****     unsigned char current;
  75:MessagesAndData.c **** 
  76:MessagesAndData.c **** 	SWITCHP = 0xFF;
 175               	.LM11:
 176 0026 8FEF      		ldi r24,lo8(-1)
 177 0028 88BB      		out 56-0x20,r24
 178               	.L12:
  77:MessagesAndData.c **** //    outp(0xFF, SWITCHP);            // Enable pullups on switch inputs
  78:MessagesAndData.c **** 
  79:MessagesAndData.c ****     while (1)
  80:MessagesAndData.c ****     {
  81:MessagesAndData.c ****         AvrXDelay(&MyTimer, 10);             // 10ms delay
 180               	.LM12:
 181 002a 6AE0      		ldi r22,lo8(10)
 182 002c 70E0      		ldi r23,hi8(10)
 183 002e 80E0      		ldi r24,lo8(MyTimer)
 184 0030 90E0      		ldi r25,hi8(MyTimer)
 185 0032 0E94 0000 		call AvrXDelay
  82:MessagesAndData.c **** //        current = inp(SWITCH);
  83:MessagesAndData.c ****         current = SWITCH;
 187               	.LM13:
 188 0036 96B3      		in r25,54-0x20
  84:MessagesAndData.c ****         if (current != SwitchMessage.switches)
 190               	.LM14:
 191 0038 8091 0000 		lds r24,SwitchMessage.0+4
 192 003c 9817      		cp r25,r24
 193 003e A9F3      		breq .L12
  85:MessagesAndData.c ****         {
  86:MessagesAndData.c ****             SwitchMessage.switches = current;
 195               	.LM15:
 196 0040 9093 0000 		sts SwitchMessage.0+4,r25
  87:MessagesAndData.c ****             AvrXSendMessage(&MyQueue, &SwitchMessage.mcb);
 198               	.LM16:
 199 0044 60E0      		ldi r22,lo8(SwitchMessage.0)
 200 0046 70E0      		ldi r23,hi8(SwitchMessage.0)
 201 0048 80E0      		ldi r24,lo8(MyQueue)
 202 004a 90E0      		ldi r25,hi8(MyQueue)
 203 004c 0E94 0000 		call AvrXSendMessage
  88:MessagesAndData.c ****             AvrXWaitMessageAck(&SwitchMessage.mcb);
 205               	.LM17:
 206 0050 80E0      		ldi r24,lo8(SwitchMessage.0)
 207 0052 90E0      		ldi r25,hi8(SwitchMessage.0)
 208 0054 0E94 0000 		call AvrXWaitMessageAck
 209 0058 E8CF      		rjmp .L12
 210               	/* epilogue: frame size=0 */
 211               	/* epilogue: noreturn */
 212               	/* epilogue end (size=0) */
 213               	/* function task2 size 26 (26) */
 219               	.Lscope2:
 221               	.global	main
 223               	main:
  89:MessagesAndData.c ****         }
  90:MessagesAndData.c ****     }
  91:MessagesAndData.c **** }
  92:MessagesAndData.c **** 
  93:MessagesAndData.c **** int main(void)                 // Main runs under the AvrX Stack
  94:MessagesAndData.c **** {
 225               	.LM18:
 226               	/* prologue: frame size=0 */
 227 005a C0E0      		ldi r28,lo8(__stack - 0)
 228 005c D0E0      		ldi r29,hi8(__stack - 0)
 229 005e DEBF      		out __SP_H__,r29
 230 0060 CDBF      		out __SP_L__,r28
 231               	/* prologue end (size=4) */
  95:MessagesAndData.c ****     AvrXSetKernelStack(0);
 233               	.LM19:
 234 0062 80E0      		ldi r24,lo8(0)
 235 0064 90E0      		ldi r25,hi8(0)
 236 0066 0E94 0000 		call AvrXSetKernelStack
  96:MessagesAndData.c **** 
  97:MessagesAndData.c ****     MCUCR = 1<<SE;
 238               	.LM20:
 239 006a 80E8      		ldi r24,lo8(-128)
 240 006c 85BF      		out 85-0x20,r24
  98:MessagesAndData.c ****     TCNT0 = TCNT0_INIT;
 242               	.LM21:
 243 006e 81EC      		ldi r24,lo8(-63)
 244 0070 82BF      		out 82-0x20,r24
  99:MessagesAndData.c ****     TCCR0 = TMC8_CK256;
 246               	.LM22:
 247 0072 84E0      		ldi r24,lo8(4)
 248 0074 83BF      		out 83-0x20,r24
 100:MessagesAndData.c ****     TIMSK = 1<<TOIE0;
 250               	.LM23:
 251 0076 81E0      		ldi r24,lo8(1)
 252 0078 89BF      		out 89-0x20,r24
 101:MessagesAndData.c **** 
 102:MessagesAndData.c ****     LEDDDR = 0xFF;
 254               	.LM24:
 255 007a 8FEF      		ldi r24,lo8(-1)
 256 007c 84BB      		out 52-0x20,r24
 103:MessagesAndData.c ****     LED   = 0xFF;
 258               	.LM25:
 259 007e 85BB      		out 53-0x20,r24
 104:MessagesAndData.c **** /*
 105:MessagesAndData.c ****     outp((1<<SE) , MCUCR);      // Enable "Sleep" instruction for idle loop
 106:MessagesAndData.c **** 
 107:MessagesAndData.c ****     outp(TCNT0_INIT, TCNT0);
 108:MessagesAndData.c ****     outp(TMC8_CK256 , TCCR0);   // Set up Timer0 for CLK/256 rate
 109:MessagesAndData.c ****     outp((1<<TOIE0), TIMSK);    // Enable0 Timer overflow interrupt
 110:MessagesAndData.c **** 
 111:MessagesAndData.c ****     outp(0xFF, LEDDDR);	        // Make LED port output and
 112:MessagesAndData.c ****     outp(0xFF, LED);              // drive high (LEDs off)
 113:MessagesAndData.c **** */
 114:MessagesAndData.c ****     AvrXRunTask(TCB(task1));	// Init and run our tasks
 261               	.LM26:
 262 0080 80E0      		ldi r24,lo8(task1Tcb)
 263 0082 90E0      		ldi r25,hi8(task1Tcb)
 264 0084 0E94 0000 		call AvrXRunTask
 115:MessagesAndData.c ****     AvrXRunTask(TCB(task2));
 266               	.LM27:
 267 0088 80E0      		ldi r24,lo8(task2Tcb)
 268 008a 90E0      		ldi r25,hi8(task2Tcb)
 269 008c 0E94 0000 		call AvrXRunTask
 116:MessagesAndData.c ****     AvrXRunTask(TCB(Monitor));
 271               	.LM28:
 272 0090 80E0      		ldi r24,lo8(MonitorTcb)
 273 0092 90E0      		ldi r25,hi8(MonitorTcb)
 274 0094 0E94 0000 		call AvrXRunTask
 117:MessagesAndData.c **** 
 118:MessagesAndData.c ****     InitSerialIO(UBRR_INIT);    // Initialize USART baud rate generator
 276               	.LM29:
 277 0098 83E3      		ldi r24,lo8(51)
 278 009a 90E0      		ldi r25,hi8(51)
 279 009c 0E94 0000 		call InitSerialIO
 119:MessagesAndData.c **** 
 120:MessagesAndData.c ****     /* Needed for EEPROM access in monitor */
 121:MessagesAndData.c **** 
 122:MessagesAndData.c ****     AvrXSetSemaphore(&EEPromMutex);
 281               	.LM30:
 282 00a0 80E0      		ldi r24,lo8(EEPromMutex)
 283 00a2 90E0      		ldi r25,hi8(EEPromMutex)
 284 00a4 0E94 0000 		call AvrXSetSemaphore
 123:MessagesAndData.c **** 
 124:MessagesAndData.c ****     Epilog();                   // Switch from AvrX Stack to first task
 286               	.LM31:
 287 00a8 0E94 0000 		call Epilog
 288               	.L14:
 125:MessagesAndData.c ****     while(1);
 290               	.LM32:
 291 00ac FFCF      		rjmp .L14
 292               	/* epilogue: frame size=0 */
 293               	/* epilogue: noreturn */
 294               	/* epilogue end (size=0) */
 295               	/* function main size 42 (38) */
 297               	.Lscope3:
 298               		.comm MonitorStk,55,1
 299               		.comm MonitorPid,6,1
 300               		.comm MyTimer,6,1
 301               		.comm MyQueue,4,1
 302               		.comm task1Stk,45,1
 303               		.comm task1Pid,6,1
 304               		.comm task2Stk,45,1
 305               		.comm task2Pid,6,1
 317               		.text
 319               	Letext:
 320               	/* File "MessagesAndData.c": code   87 = 0x0057 (  83), prologues   4, epilogues   0 */
DEFINED SYMBOLS
                            *ABS*:00000000 MessagesAndData.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
     /tmp/cccvRoQO.s:82     .progmem.data:00000000 task2Tcb
                            *COM*:0000002d task2Stk
     /tmp/cccvRoQO.s:169    .text:00000026 task2
                            *COM*:00000006 task2Pid
     /tmp/cccvRoQO.s:90     .progmem.data:00000007 task1Tcb
                            *COM*:0000002d task1Stk
     /tmp/cccvRoQO.s:135    .text:00000010 task1
                            *COM*:00000006 task1Pid
     /tmp/cccvRoQO.s:98     .progmem.data:0000000e MonitorTcb
                            *COM*:00000037 MonitorStk
                            *COM*:00000006 MonitorPid
     /tmp/cccvRoQO.s:107    .text:00000000 __vector_11
                            *COM*:00000004 MyQueue
                             .bss:00000000 SwitchMessage.0
                            *COM*:00000006 MyTimer
     /tmp/cccvRoQO.s:223    .text:0000005a main
     /tmp/cccvRoQO.s:319    .text:000000ae Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
Monitor
IntProlog
AvrXTimerHandler
Epilog
AvrXWaitMessage
AvrXAckMessage
AvrXDelay
AvrXSendMessage
AvrXWaitMessageAck
__stack
AvrXSetKernelStack
AvrXRunTask
InitSerialIO
EEPromMutex
AvrXSetSemaphore
