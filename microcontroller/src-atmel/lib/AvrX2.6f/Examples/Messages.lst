   1               		.file	"Messages.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  93               	.global	task2Tcb
  94               		.section	.progmem.data,"a",@progbits
  97               	task2Tcb:
  98 0000 0000      		.word	task2Stk+54
  99 0002 0000      		.word	pm(task2)
 100 0004 0000      		.word	task2Pid
 101 0006 03        		.byte	3
 102               	.global	task1Tcb
 105               	task1Tcb:
 106 0007 0000      		.word	task1Stk+54
 107 0009 0000      		.word	pm(task1)
 108 000b 0000      		.word	task1Pid
 109 000d 03        		.byte	3
 110               	.global	MonitorTcb
 113               	MonitorTcb:
 114 000e 0000      		.word	MonitorStk+74
 115 0010 0000      		.word	pm(Monitor)
 116 0012 0000      		.word	MonitorPid
 117 0014 00        		.byte	0
 118               		.text
 120               	.global	__vector_11
 122               	__vector_11:
   1:Messages.c    **** /*
   2:Messages.c    **** 	Example of using different MessageControlBlocks as
   3:Messages.c    **** 	specific messages.  In this case "Switch Up" and "Switch Down"
   4:Messages.c    **** 
   5:Messages.c    **** 	Pay attention to the AvrXStack defined in the makefile on the
   6:Messages.c    **** 	linker/loader command line.  In general this should match the
   7:Messages.c    **** 	stack passed to main() (end of ram).
   8:Messages.c    **** 
   9:Messages.c    **** 	The task definitions in this example have 20 extra bytes for
  10:Messages.c    **** 	the task stack.	Typically only one or two extra words of stack
  11:Messages.c    **** 	are needed for AvrX calls.  All other is for user code.
  12:Messages.c    **** */
  13:Messages.c    **** //#define ENABLE_BIT_DEFINITIONS
  14:Messages.c    **** //#define _SFR_ASM_COMPAT 1
  15:Messages.c    **** #include <avrx-io.h>			// This defers to avr/io.h for GCC
  16:Messages.c    **** #include <avrx-signal.h>		// This defers to avr/signal.h for GCC
  17:Messages.c    **** #include "Avrx.h"
  18:Messages.c    **** #include "serialio.h"           // From AvrX...
  19:Messages.c    **** #include "hardware.h"
  20:Messages.c    **** 
  21:Messages.c    **** #include <avr/pgmspace.h>
  22:Messages.c    **** 
  23:Messages.c    **** AVRX_IAR_TASK(Monitor, 0, 20, 0);
  24:Messages.c    **** AVRX_GCC_TASK(Monitor, 40, 0);//20
  25:Messages.c    **** 
  26:Messages.c    **** TimerControlBlock   MyTimer;    // Declare the control blocks needed for timers
  27:Messages.c    **** MessageControlBlock SwitchUp,   // Simple messages (no internal data)
  28:Messages.c    ****                     SwitchDown;
  29:Messages.c    **** MessageQueue        MyQueue;    // The message queue
  30:Messages.c    **** 
  31:Messages.c    **** /*
  32:Messages.c    ****  Timer 0 Overflow Interrupt Handler
  33:Messages.c    **** 
  34:Messages.c    ****  Prototypical Interrupt handler:
  35:Messages.c    ****  . Switch to kernel context
  36:Messages.c    ****  . handle interrupt
  37:Messages.c    ****  . switch back to interrupted context.
  38:Messages.c    ****  */
  39:Messages.c    **** #pragma optimize=z 4
  40:Messages.c    **** AVRX_SIGINT(SIG_OVERFLOW0)
  41:Messages.c    **** {
 124               	.LM1:
 125               	/* prologue: frame size=0 */
 126               	/* prologue: naked */
 127               	/* prologue end (size=0) */
  42:Messages.c    ****     IntProlog();                // Switch to kernel stack/context
 129               	.LM2:
 130 0000 0E94 0000 		call IntProlog
  43:Messages.c    ****     TCNT0 = TCNT0_INIT;
 132               	.LM3:
 133 0004 81EC      		ldi r24,lo8(-63)
 134 0006 82BF      		out 82-0x20,r24
  44:Messages.c    ****     AvrXTimerHandler();         // Call Time queue manager
 136               	.LM4:
 137 0008 0E94 0000 		call AvrXTimerHandler
  45:Messages.c    ****     Epilog();                   // Return to tasks
 139               	.LM5:
 140 000c 0E94 0000 		call Epilog
 141               	/* epilogue: frame size=0 */
 142               	/* epilogue: naked */
 143               	/* epilogue end (size=0) */
 144               	/* function __vector_11 size 8 (8) */
 146               	.Lscope0:
 148               	.global	task1
 150               	task1:
  46:Messages.c    **** }
  47:Messages.c    **** /*
  48:Messages.c    ****  Task 1 Waits for a message, parses it and takes action.
  49:Messages.c    ****  */
  50:Messages.c    **** AVRX_IAR_TASKDEF(task1, 0, 20, 3)
  51:Messages.c    **** AVRX_GCC_TASKDEF(task1, 20, 3)
  52:Messages.c    **** {
 152               	.LM6:
 153               	/* prologue: frame size=0 */
 154               	/* prologue end (size=0) */
 155               	.L3:
  53:Messages.c    ****     MessageControlBlock *p;
  54:Messages.c    **** 
  55:Messages.c    ****     while (1)
  56:Messages.c    ****     {
  57:Messages.c    ****         p = AvrXWaitMessage(&MyQueue);
 157               	.LM7:
 158 0010 80E0      		ldi r24,lo8(MyQueue)
 159 0012 90E0      		ldi r25,hi8(MyQueue)
 160 0014 0E94 0000 		call AvrXWaitMessage
 161 0018 EC01      		movw r28,r24
  58:Messages.c    ****         if (p == &SwitchUp)
 163               	.LM8:
 164 001a 80E0      		ldi r24,hi8(SwitchUp)
 165 001c C030      		cpi r28,lo8(SwitchUp)
 166 001e D807      		cpc r29,r24
 167 0020 19F4      		brne .L5
  59:Messages.c    ****         	LED = 0xFF;
 169               	.LM9:
 170 0022 8FEF      		ldi r24,lo8(-1)
 171 0024 85BB      		out 53-0x20,r24
 172 0026 08C0      		rjmp .L6
 173               	.L5:
  60:Messages.c    ****         else if (p == &SwitchDown)
 175               	.LM10:
 176 0028 80E0      		ldi r24,hi8(SwitchDown)
 177 002a C030      		cpi r28,lo8(SwitchDown)
 178 002c D807      		cpc r29,r24
 179 002e 11F4      		brne .L7
  61:Messages.c    ****         	LED = 0x00;
 181               	.LM11:
 182 0030 15BA      		out 53-0x20,__zero_reg__
 183 0032 02C0      		rjmp .L6
 184               	.L7:
  62:Messages.c    ****         else
  63:Messages.c    ****             AvrXHalt();
 186               	.LM12:
 187 0034 0E94 0000 		call AvrXHalt
 188               	.L6:
  64:Messages.c    ****         AvrXAckMessage(p);
 190               	.LM13:
 191 0038 CE01      		movw r24,r28
 192 003a 0E94 0000 		call AvrXAckMessage
 193 003e E8CF      		rjmp .L3
 194               	/* epilogue: frame size=0 */
 195               	/* epilogue: noreturn */
 196               	/* epilogue end (size=0) */
 197               	/* function task1 size 24 (24) */
 202               	.Lscope1:
 203               		.section	.progmem.data
 206               	__c.0:
 207 0015 4861 6C6C 		.string	"Hallo"
 207      6F00 
 208               		.text
 210               	.global	task2
 212               	task2:
  65:Messages.c    ****     }
  66:Messages.c    **** }
  67:Messages.c    **** /*
  68:Messages.c    ****  Task 2 Checks switches every 10ms and sends a message SWITCH:0 changes
  69:Messages.c    ****  state
  70:Messages.c    ****  */
  71:Messages.c    **** AVRX_IAR_TASKDEF(task2, 0, 20, 3)
  72:Messages.c    **** AVRX_GCC_TASKDEF(task2, 20, 3)
  73:Messages.c    **** {
 214               	.LM14:
 215               	/* prologue: frame size=0 */
 216               	/* prologue end (size=0) */
  74:Messages.c    ****     unsigned char previous, current;
  75:Messages.c    **** 
  76:Messages.c    ****     previous = SWITCH;     // Keep compiler happy
 218               	.LM15:
 219 0040 16B3      		in r17,54-0x20
 220               	.L19:
  77:Messages.c    **** 
  78:Messages.c    ****     while (1)
  79:Messages.c    ****     {
  80:Messages.c    ****         AvrXDelay(&MyTimer, 10);             // 10ms delay
 222               	.LM16:
 223 0042 6AE0      		ldi r22,lo8(10)
 224 0044 70E0      		ldi r23,hi8(10)
 225 0046 80E0      		ldi r24,lo8(MyTimer)
 226 0048 90E0      		ldi r25,hi8(MyTimer)
 227 004a 0E94 0000 		call AvrXDelay
  81:Messages.c    ****         if (previous != (current = (SWITCH & 0x01)))
 229               	.LM17:
 230 004e C6B3      		in r28,54-0x20
 231 0050 C170      		andi r28,lo8(1)
 232 0052 1C17      		cp r17,r28
 233 0054 B1F3      		breq .L19
  82:Messages.c    ****         {
  83:Messages.c    **** 			_PrintString(PSTR("Hallo"));
 235               	.LM18:
 236 0056 80E0      		ldi r24,lo8(__c.0)
 237 0058 90E0      		ldi r25,hi8(__c.0)
 238 005a 0E94 0000 		call _PrintString
  84:Messages.c    ****             if (current == 0x01)
 240               	.LM19:
 241 005e C130      		cpi r28,lo8(1)
 242 0060 49F4      		brne .L13
  85:Messages.c    ****             {
  86:Messages.c    ****                 AvrXSendMessage(&MyQueue, &SwitchUp);
 244               	.LM20:
 245 0062 60E0      		ldi r22,lo8(SwitchUp)
 246 0064 70E0      		ldi r23,hi8(SwitchUp)
 247 0066 80E0      		ldi r24,lo8(MyQueue)
 248 0068 90E0      		ldi r25,hi8(MyQueue)
 249 006a 0E94 0000 		call AvrXSendMessage
  87:Messages.c    ****                 AvrXWaitMessageAck(&SwitchUp);
 251               	.LM21:
 252 006e 80E0      		ldi r24,lo8(SwitchUp)
 253 0070 90E0      		ldi r25,hi8(SwitchUp)
 254 0072 08C0      		rjmp .L18
 255               	.L13:
  88:Messages.c    ****             }
  89:Messages.c    ****             else
  90:Messages.c    ****             {
  91:Messages.c    ****                 AvrXSendMessage(&MyQueue, &SwitchDown);
 257               	.LM22:
 258 0074 60E0      		ldi r22,lo8(SwitchDown)
 259 0076 70E0      		ldi r23,hi8(SwitchDown)
 260 0078 80E0      		ldi r24,lo8(MyQueue)
 261 007a 90E0      		ldi r25,hi8(MyQueue)
 262 007c 0E94 0000 		call AvrXSendMessage
  92:Messages.c    ****                 AvrXWaitMessageAck(&SwitchDown);
 264               	.LM23:
 265 0080 80E0      		ldi r24,lo8(SwitchDown)
 266 0082 90E0      		ldi r25,hi8(SwitchDown)
 267               	.L18:
 268 0084 0E94 0000 		call AvrXWaitMessageAck
  93:Messages.c    ****             }
  94:Messages.c    ****             previous = current;
 270               	.LM24:
 271 0088 1C2F      		mov r17,r28
 272 008a DBCF      		rjmp .L19
 273               	/* epilogue: frame size=0 */
 274               	/* epilogue: noreturn */
 275               	/* epilogue end (size=0) */
 276               	/* function task2 size 38 (38) */
 282               	.Lscope2:
 284               	.global	main
 286               	main:
  95:Messages.c    ****         }
  96:Messages.c    ****     }
  97:Messages.c    **** }
  98:Messages.c    **** 
  99:Messages.c    **** int main(void)                 // Main runs under the AvrX Stack
 100:Messages.c    **** {
 288               	.LM25:
 289               	/* prologue: frame size=0 */
 290 008c C0E0      		ldi r28,lo8(__stack - 0)
 291 008e D0E0      		ldi r29,hi8(__stack - 0)
 292 0090 DEBF      		out __SP_H__,r29
 293 0092 CDBF      		out __SP_L__,r28
 294               	/* prologue end (size=4) */
 101:Messages.c    ****     AvrXSetKernelStack(0);
 296               	.LM26:
 297 0094 80E0      		ldi r24,lo8(0)
 298 0096 90E0      		ldi r25,hi8(0)
 299 0098 0E94 0000 		call AvrXSetKernelStack
 102:Messages.c    **** 
 103:Messages.c    **** 	MCUCR = _BV(SE);
 301               	.LM27:
 302 009c 80E8      		ldi r24,lo8(-128)
 303 009e 85BF      		out 85-0x20,r24
 104:Messages.c    **** 	TCNT0 = TCNT0_INIT;
 305               	.LM28:
 306 00a0 81EC      		ldi r24,lo8(-63)
 307 00a2 82BF      		out 82-0x20,r24
 105:Messages.c    **** 	TCCR0 = TMC8_CK256;
 309               	.LM29:
 310 00a4 84E0      		ldi r24,lo8(4)
 311 00a6 83BF      		out 83-0x20,r24
 106:Messages.c    **** 	TIMSK = _BV(TOIE0);
 313               	.LM30:
 314 00a8 81E0      		ldi r24,lo8(1)
 315 00aa 89BF      		out 89-0x20,r24
 107:Messages.c    **** 	LEDDDR = 0xFF;
 317               	.LM31:
 318 00ac 8FEF      		ldi r24,lo8(-1)
 319 00ae 84BB      		out 52-0x20,r24
 108:Messages.c    **** 	LED = 0xFF;
 321               	.LM32:
 322 00b0 85BB      		out 53-0x20,r24
 109:Messages.c    **** 	SWITCHP = 0x0F;
 324               	.LM33:
 325 00b2 8FE0      		ldi r24,lo8(15)
 326 00b4 88BB      		out 56-0x20,r24
 110:Messages.c    **** 
 111:Messages.c    ****     AvrXRunTask(TCB(task1));
 328               	.LM34:
 329 00b6 80E0      		ldi r24,lo8(task1Tcb)
 330 00b8 90E0      		ldi r25,hi8(task1Tcb)
 331 00ba 0E94 0000 		call AvrXRunTask
 112:Messages.c    ****     AvrXRunTask(TCB(task2));
 333               	.LM35:
 334 00be 80E0      		ldi r24,lo8(task2Tcb)
 335 00c0 90E0      		ldi r25,hi8(task2Tcb)
 336 00c2 0E94 0000 		call AvrXRunTask
 113:Messages.c    ****     //AvrXRunTask(TCB(Monitor));
 114:Messages.c    **** 
 115:Messages.c    ****     InitSerialIO(UBRR_INIT);    // Initialize USART baud rate generator
 338               	.LM36:
 339 00c6 83E3      		ldi r24,lo8(51)
 340 00c8 90E0      		ldi r25,hi8(51)
 341 00ca 0E94 0000 		call InitSerialIO
 116:Messages.c    **** 
 117:Messages.c    ****     /* Needed for EEPROM access in monitor */
 118:Messages.c    **** 
 119:Messages.c    ****     AvrXSetSemaphore(&EEPromMutex);
 343               	.LM37:
 344 00ce 80E0      		ldi r24,lo8(EEPromMutex)
 345 00d0 90E0      		ldi r25,hi8(EEPromMutex)
 346 00d2 0E94 0000 		call AvrXSetSemaphore
 120:Messages.c    **** 
 121:Messages.c    ****     Epilog();                   // Switch from AvrX Stack to first task
 348               	.LM38:
 349 00d6 0E94 0000 		call Epilog
 350               	.L21:
 122:Messages.c    ****     while(1);
 352               	.LM39:
 353 00da FFCF      		rjmp .L21
 354               	/* epilogue: frame size=0 */
 355               	/* epilogue: noreturn */
 356               	/* epilogue end (size=0) */
 357               	/* function main size 40 (36) */
 359               	.Lscope3:
 360               		.comm MonitorStk,75,1
 361               		.comm MonitorPid,6,1
 362               		.comm MyTimer,6,1
 363               		.comm SwitchUp,4,1
 364               		.comm SwitchDown,4,1
 365               		.comm MyQueue,4,1
 366               		.comm task1Stk,55,1
 367               		.comm task1Pid,6,1
 368               		.comm task2Stk,55,1
 369               		.comm task2Pid,6,1
 383               		.text
 385               	Letext:
 386               	/* File "Messages.c": code  110 = 0x006e ( 106), prologues   4, epilogues   0 */
DEFINED SYMBOLS
                            *ABS*:00000000 Messages.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
     /tmp/ccNFo93k.s:97     .progmem.data:00000000 task2Tcb
                            *COM*:00000037 task2Stk
     /tmp/ccNFo93k.s:212    .text:00000040 task2
                            *COM*:00000006 task2Pid
     /tmp/ccNFo93k.s:105    .progmem.data:00000007 task1Tcb
                            *COM*:00000037 task1Stk
     /tmp/ccNFo93k.s:150    .text:00000010 task1
                            *COM*:00000006 task1Pid
     /tmp/ccNFo93k.s:113    .progmem.data:0000000e MonitorTcb
                            *COM*:0000004b MonitorStk
                            *COM*:00000006 MonitorPid
     /tmp/ccNFo93k.s:122    .text:00000000 __vector_11
                            *COM*:00000004 MyQueue
                            *COM*:00000004 SwitchUp
                            *COM*:00000004 SwitchDown
     /tmp/ccNFo93k.s:206    .progmem.data:00000015 __c.0
                            *COM*:00000006 MyTimer
     /tmp/ccNFo93k.s:286    .text:0000008c main
     /tmp/ccNFo93k.s:385    .text:000000dc Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
Monitor
IntProlog
AvrXTimerHandler
Epilog
AvrXWaitMessage
AvrXHalt
AvrXAckMessage
AvrXDelay
_PrintString
AvrXSendMessage
AvrXWaitMessageAck
__stack
AvrXSetKernelStack
AvrXRunTask
InitSerialIO
EEPromMutex
AvrXSetSemaphore
