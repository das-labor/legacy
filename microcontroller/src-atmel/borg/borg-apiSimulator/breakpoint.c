#include "pixel.h"


unsigned char bp_image[3][18][8] = {
  {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF}
 , {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF}
 , {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF}
 , {0xFF, 0x33, 0xDF, 0xFF, 0x7F, 0x08, 0xF0, 0xFF}
 , {0x1F, 0x3B, 0x9F, 0x3F, 0x10, 0x99, 0xF1, 0xFF}
 , {0x33, 0x33, 0x87, 0x3C, 0xF3, 0x11, 0x73, 0xFF}
 , {0x3B, 0x03, 0x87, 0x60, 0xF0, 0x33, 0x61, 0xFF}
 , {0xC3, 0xFF, 0xB7, 0xCC, 0xE3, 0xF3, 0x7F, 0xFE}
 , {0xFF, 0x7F, 0xB6, 0xE1, 0xFF, 0xFF, 0x7F, 0xFD}
 , {0xFF, 0x7F, 0xFE, 0xFF, 0xFF, 0x0F, 0x00, 0xC1}
 , {0xFF, 0x7F, 0xFE, 0x8C, 0x01, 0x04, 0x80, 0xE7}
 , {0xFF, 0x1F, 0x04, 0x8C, 0x71, 0x8C, 0x83, 0xF7}
 , {0xFF, 0x7F, 0xC6, 0x18, 0x71, 0x0C, 0x07, 0xF7}
 , {0xFF, 0x7F, 0xC6, 0x18, 0x61, 0x08, 0x07, 0xE0}
 , {0xFF, 0x7F, 0xCE, 0x18, 0x63, 0x08, 0x07, 0xC4}
 , {0xFF, 0x3F, 0xCE, 0x18, 0x03, 0x18, 0x00, 0xDE}
 , {0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF}
 , {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF}
 }
 ,{{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF}
 , {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF}
 , {0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF}
 , {0xFF, 0x01, 0xDF, 0xFF, 0x3F, 0x08, 0xF0, 0xFF}
 , {0x1F, 0x31, 0x9F, 0x37, 0x10, 0x99, 0xF1, 0xFF}
 , {0x31, 0x31, 0x87, 0x30, 0xF3, 0x11, 0x73, 0xFF}
 , {0x33, 0x03, 0x87, 0x60, 0xE0, 0x13, 0x60, 0xFF}
 , {0xC3, 0xFF, 0xB7, 0xCC, 0xE0, 0xF3, 0x7F, 0xFE}
 , {0xFF, 0x3F, 0xB6, 0xE0, 0xFF, 0xFF, 0x7F, 0x9C}
 , {0xFF, 0x3F, 0xFE, 0xFF, 0xFF, 0x0F, 0x00, 0xC1}
 , {0xFF, 0x3F, 0x3E, 0x8C, 0x01, 0x04, 0x80, 0xC7}
 , {0xFF, 0x1F, 0x04, 0x88, 0x31, 0x8C, 0x03, 0xE7}
 , {0xFF, 0x7F, 0xC6, 0x18, 0x71, 0x0C, 0x03, 0xF7}
 , {0xFF, 0x7F, 0xC6, 0x18, 0x61, 0x08, 0x07, 0xE0}
 , {0xFF, 0x7F, 0xC4, 0x18, 0x63, 0x08, 0x07, 0xC4}
 , {0xFF, 0x3F, 0xCE, 0x18, 0x03, 0x18, 0x00, 0xCE}
 , {0xFF, 0x3F, 0xCE, 0x39, 0x07, 0x7C, 0x00, 0xBF}
 , {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF}
 }
 ,{{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF}
 , {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF}
 , {0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF}
 , {0xBF, 0x01, 0x9F, 0xFF, 0x1F, 0x08, 0xF0, 0xFF}
 , {0x1F, 0x31, 0x9F, 0x27, 0x10, 0x91, 0xB1, 0xFF}
 , {0x01, 0x31, 0x86, 0x20, 0xB3, 0x11, 0x61, 0xFF}
 , {0x31, 0x01, 0x87, 0x00, 0xE0, 0x11, 0x60, 0xFF}
 , {0x83, 0xFF, 0x87, 0xC4, 0xE0, 0x33, 0x7C, 0xFE}
 , {0xFF, 0x3F, 0x92, 0xE0, 0xFC, 0xFF, 0x3F, 0x80}
 , {0xFF, 0x3F, 0xFE, 0xFF, 0x7F, 0x06, 0x00, 0x81}
 , {0xFF, 0x3F, 0x0E, 0x8C, 0x01, 0x04, 0x80, 0xC7}
 , {0xFF, 0x1F, 0x00, 0x08, 0x31, 0x04, 0x03, 0xE3}
 , {0xFF, 0x7F, 0xC6, 0x08, 0x61, 0x08, 0x03, 0xF7}
 , {0xFF, 0x7F, 0xC4, 0x18, 0x61, 0x08, 0x07, 0xE0}
 , {0xFF, 0x7F, 0xC4, 0x18, 0x61, 0x08, 0x02, 0xC0}
 , {0xFF, 0x3F, 0xCC, 0x18, 0x03, 0x18, 0x00, 0xCE}
 , {0xFF, 0x3F, 0xCE, 0x19, 0x07, 0x3C, 0x00, 0xBF}
 , {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFE}}
 };

unsigned char image23c3[3][17][4] = {
  {{0xFF, 0x7F, 0xFF, 0xFF}
 , {0xFF, 0x1F, 0xF8, 0xFF}
 , {0xFF, 0x8F, 0xF1, 0xFF}
 , {0x07, 0x86, 0xE1, 0xFF}
 , {0x43, 0x84, 0xE1, 0xF0}
 , {0xE3, 0xFF, 0x61, 0xC0}
 , {0xC3, 0xFF, 0x21, 0xDC}
 , {0x83, 0xFF, 0x21, 0x7C}
 , {0xC1, 0xFF, 0x61, 0x78}
 , {0xE1, 0xFF, 0x31, 0x78}
 , {0xF0, 0xFF, 0x11, 0x7E}
 , {0x71, 0x00, 0x18, 0xFE}
 , {0x21, 0x00, 0x1C, 0xEF}
 , {0x03, 0xFE, 0x1F, 0x06}
 , {0x0F, 0xFF, 0x3F, 0xC2}
 , {0xFF, 0xFF, 0x7F, 0xE0}
 , {0xFF, 0xFF, 0xFF, 0xFF}
 }
 ,{{0xFF, 0x3F, 0xFC, 0xFF}
 , {0xFF, 0x0F, 0xF8, 0xFF}
 , {0x9F, 0x8F, 0xF1, 0xFF}
 , {0x07, 0x86, 0xE1, 0xFF}
 , {0x03, 0x84, 0xE1, 0xF0}
 , {0xE3, 0xFF, 0x61, 0xC0}
 , {0xC3, 0xFF, 0x21, 0xCC}
 , {0x83, 0xFF, 0x21, 0x7C}
 , {0xC1, 0xFF, 0x61, 0x78}
 , {0xE0, 0xFF, 0x21, 0x78}
 , {0x70, 0xFF, 0x10, 0x7C}
 , {0x70, 0x00, 0x18, 0xFE}
 , {0x21, 0x00, 0x1C, 0x06}
 , {0x03, 0xFC, 0x1F, 0x06}
 , {0x07, 0xFF, 0x1F, 0x82}
 , {0xFF, 0xFF, 0x3F, 0xC0}
 , {0xFF, 0xFF, 0xFF, 0xFB}
 }
 ,{{0xFF, 0x3F, 0xFC, 0xFF}
 , {0xFF, 0x0F, 0xF8, 0xFF}
 , {0x8F, 0x87, 0xF0, 0xFF}
 , {0x03, 0x86, 0xE1, 0xFF}
 , {0x03, 0x84, 0xE1, 0xE0}
 , {0xE3, 0xFF, 0x61, 0xC0}
 , {0xC3, 0xFF, 0x21, 0xC4}
 , {0x83, 0xFF, 0x21, 0x7C}
 , {0x81, 0xFF, 0x21, 0x78}
 , {0xE0, 0xFF, 0x20, 0x78}
 , {0x70, 0xFC, 0x10, 0x7C}
 , {0x20, 0x00, 0x10, 0xFE}
 , {0x21, 0x00, 0x0C, 0x06}
 , {0x01, 0xFC, 0x1F, 0x06}
 , {0x07, 0xFF, 0x1F, 0x80}
 , {0xFF, 0xFF, 0x3F, 0xC0}
 , {0xFF, 0xFF, 0xFF, 0xF9}
 }
 };
 


// Position in 
//	  i[][0][0]	i[][0][1]
//	  
// 
//    p[][0][0] p[][0][1] 
//    10001001  10010101 

// image


void drawPixmapPos(int x, int y) {
	unsigned char p, i;
	unsigned long buf;
	for (p = 0; p < 3; p++) {
			for (i = 0; i < 16; i++) {
				buf = bp_image[p][(i+y)%18][(0 + x/8)%8] <<  8;
				if (x < 58)
					buf |= bp_image[p][(i+y)%18][(1 + x/8)%8] << 16; 
				if (x > 7)
					buf |= bp_image[p][(i+y)%18][(-1 + x/8)%8];
				pixmap[p][i][1] = (unsigned char) (buf >> ((x%8)+8));
				pixmap[p][i][0] = (unsigned char) (buf >> ((x%8)+0));
		}
	}
}

void breakpoint() {
	unsigned char p, x, i;
	clear_screen(3);
	for (i = 0; i < 63; i++) {
		drawPixmapPos(i, 2)	;
		wait(45);
	}
	wait(100);	
	for (i = 63; i > 7; i--) {
		drawPixmapPos(i, 0)	;
		wait(45);
	}
	wait(1000);
	for (x = 0; x < 4; x++) {
		for (p = 0; p < 3; p++) {
			for (i = 0; i < 16; i++) {
				pixmap[p][i][0] = (pixmap[p][i][0] & 0xf0) << 1 |
				                  (pixmap[p][i][0] & 0x0f) >> 1;
				pixmap[p][i][1] = (pixmap[p][i][1] & 0xf0) << 1 |
				                  (pixmap[p][i][1] & 0x0f) >> 1;				  
								
			}
		}
		wait(200);
	}
	clear_screen(0);
	wait(100);
}

//void drawDrachen(point p1, po);


/************************************************************************/

/** Table for the calculation of sinus. It only has one half wave, because
 *  the others can be generated of it.
 *  
 *  64 = sin(90 grad) = 1.0 = sinTab[16]
 */
char sinTab[] = {0, 6, 12, 19, 24, 30, 36, 41, 45, 49, 53, 56, 59, 61, 63, 64, 64};

/** Sin(64) = sin(360 grad) and sin(90 grad) = Sin(16) = 64. Its using the one halfwave
 *  of sinTab to generate a whole sinus. It e
 */		 
char Sin(unsigned char a) {
	a %= 64;
	if (a < 17) {
		return  sinTab[a];
	} else if (a < 33) {
		return  sinTab[32-a];
	} else if (a < 49) {
		return -sinTab[a-32];
	} else {
		return -sinTab[64-a];
	}
}	

inline char Cos(unsigned char a) {
	return Sin(a+16);
}

#define NUM_CIRCLE 7

void schwarzesLoch2() {
	pixel circlePoints[NUM_CIRCLE][8];
	unsigned char  i, j, firstRadius = 80, helpRadius, angle = 0;
	unsigned int k;
	// init data
	for (k = 0; k < 400; k++) {	
		helpRadius = firstRadius;
		for (i = 0; i < NUM_CIRCLE; i++) {
			for (j = 0; j < 8; j++) {
				if (i & 1) {
					circlePoints[i][j].x = 64 + (Cos(angle + i*8)*helpRadius)/64;
					circlePoints[i][j].y = 64 + (Sin(angle + i*8)*helpRadius)/64;
				
				} else {
					circlePoints[i][j].x = 64 + (Cos(angle + i*8 + 4)*helpRadius)/64;
					circlePoints[i][j].y = 64 + (Sin(angle + i*8 + 4)*helpRadius)/64;
				} 
				// only for testing
				if (circlePoints[i][j].x < 64 &&
				    circlePoints[i][j].y < 64)
					setpixel((pixel) {circlePoints[i][j].x/8, circlePoints[i][j].y/8}, 3);
			}
			helpRadius = (helpRadius*2)/3; 
		}
		wait(50);
		clear_screen(0);
		angle++;
		firstRadius += 5;
		if (firstRadius > 119)
			firstRadius = 80;
	}
}

void schwarzesLoch() {
	pixel circlePoints[NUM_CIRCLE][8];
	unsigned char  add = 0, i, j, firstRadius = 80, helpRadius, angle = 0, x, y;
	unsigned int k;
	// init data
	for (k = 0; k < 800; k++) {
		if (k > 300)
			add = k / 16;
		helpRadius = firstRadius;
		for (i = 0; i < NUM_CIRCLE; i++) {
			for (j = 0; j < 8; j++) {
				if (j & 1) {
					circlePoints[i][j].x = 64 + (Cos(angle + j*8)*helpRadius)/64;
					circlePoints[i][j].y = 64 + (Sin(angle + add + j*8)*helpRadius)/64;
				
				} else {
					circlePoints[i][j].x = 64 + (Cos(angle + j*8 + 4)*helpRadius)/64;
					circlePoints[i][j].y = 64 + (Sin(angle + add + j*8 + 4)*helpRadius)/64;
				} 
				x = circlePoints[i][j].x/8;
				y = circlePoints[i][j].y/8;
				if (x < 16 && y < 16)
					setpixel((pixel) {x, y}, 3);
			}
			helpRadius = (helpRadius*2)/3; 
		}
		wait(30);
		clear_screen(0);
		angle++;
		firstRadius += 2;
		if (firstRadius > 119)
			firstRadius = 80;
	}
}

