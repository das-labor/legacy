   1               		.file	"xcan.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 115               	.global	mcp_status
 117               	mcp_status:
   1:xcan.c        **** #include <avr/io.h>
   2:xcan.c        **** #include <string.h>
   3:xcan.c        **** 
   4:xcan.c        **** #include <avrx.h>
   5:xcan.c        **** #include <avrx-io.h>
   6:xcan.c        **** 
   7:xcan.c        **** #include <avrx-signal.h>
   8:xcan.c        **** #include <AvrXFifo.h>
   9:xcan.c        **** 
  10:xcan.c        **** #include "config.h"
  11:xcan.c        **** #include "xcan.h"
  12:xcan.c        **** #include "spi.h"
  13:xcan.c        **** 
  14:xcan.c        **** #define spi_clear_ss() SPI_PORT |= (1<<SPI_PIN_SS)
  15:xcan.c        **** #define spi_set_ss() SPI_PORT &= ~(1<<SPI_PIN_SS)
  16:xcan.c        **** 
  17:xcan.c        **** //Registers
  18:xcan.c        **** #define RXF0SIDH 0x00
  19:xcan.c        **** #define RXF0SIDL 0x01
  20:xcan.c        **** #define RXF0EID8 0x02
  21:xcan.c        **** #define RXF0EID0 0x03
  22:xcan.c        **** #define RXF1SIDH 0x04
  23:xcan.c        **** #define RXF1SIDL 0x05
  24:xcan.c        **** #define RXF1EID8 0x06
  25:xcan.c        **** #define RXF1EID0 0x07
  26:xcan.c        **** #define RXF2SIDH 0x08
  27:xcan.c        **** #define RXF2SIDL 0x09
  28:xcan.c        **** #define RXF2EID8 0x0A
  29:xcan.c        **** #define RXF2EID0 0x0B
  30:xcan.c        **** #define BFPCTRL 0x0C
  31:xcan.c        **** #define TXRTSCTRL 0x0D
  32:xcan.c        **** #define CANSTAT 0x0E
  33:xcan.c        **** #define CANCTRL 0x0F
  34:xcan.c        **** #define RXF3SIDH 0x10
  35:xcan.c        **** #define RXF3SIDL 0x11
  36:xcan.c        **** #define RXF3EID8 0x12
  37:xcan.c        **** #define RXF3EID0 0x13
  38:xcan.c        **** #define RXF4SIDH 0x14
  39:xcan.c        **** #define RXF4SIDL 0x15
  40:xcan.c        **** #define RXF4EID8 0x16
  41:xcan.c        **** #define RXF4EID0 0x17
  42:xcan.c        **** #define RXF5SIDH 0x18
  43:xcan.c        **** #define RXF5SIDL 0x19
  44:xcan.c        **** #define RXF5EID8 0x1A
  45:xcan.c        **** #define RXF5EID0 0x1B
  46:xcan.c        **** #define TEC 0x1C
  47:xcan.c        **** #define REC 0x1D
  48:xcan.c        **** #define RXM0SIDH 0x20
  49:xcan.c        **** #define RXM0SIDL 0x21
  50:xcan.c        **** #define RXM0EID8 0x22
  51:xcan.c        **** #define RXM0EID0 0x23
  52:xcan.c        **** #define RXM1SIDH 0x24
  53:xcan.c        **** #define RXM1SIDL 0x25
  54:xcan.c        **** #define RXM1EID8 0x26
  55:xcan.c        **** #define RXM1EID0 0x27
  56:xcan.c        **** #define CNF3 0x28
  57:xcan.c        **** #define CNF2 0x29
  58:xcan.c        **** #define CNF1 0x2A
  59:xcan.c        **** #define CANINTE 0x2B
  60:xcan.c        **** 	#define MERRE 7
  61:xcan.c        **** 	#define WAKIE 6
  62:xcan.c        **** 	#define ERRIE 5
  63:xcan.c        **** 	#define TX2IE 4
  64:xcan.c        **** 	#define TX1IE 3
  65:xcan.c        **** 	#define TX0IE 2
  66:xcan.c        **** 	#define RX1IE 1
  67:xcan.c        **** 	#define RX0IE 0
  68:xcan.c        **** #define CANINTF 0x2C
  69:xcan.c        **** 	#define MERRF 7
  70:xcan.c        **** 	#define WAKIF 6
  71:xcan.c        **** 	#define ERRIF 5
  72:xcan.c        **** 	#define TX2IF 4
  73:xcan.c        **** 	#define TX1IF 3
  74:xcan.c        **** 	#define TX0IF 2
  75:xcan.c        **** 	#define RX1IF 1
  76:xcan.c        **** 	#define RX0IF 0
  77:xcan.c        **** #define EFLG 0x2D
  78:xcan.c        **** #define TXB0CTRL 0x30
  79:xcan.c        **** 	#define TXREQ 3
  80:xcan.c        **** #define TXB0SIDH 0x31
  81:xcan.c        **** #define TXB0SIDL 0x32
  82:xcan.c        **** 	#define EXIDE 3
  83:xcan.c        **** #define TXB0EID8 0x33
  84:xcan.c        **** #define TXB0EID0 0x34
  85:xcan.c        **** #define TXB0DLC 0x35
  86:xcan.c        **** #define TXB0D0 0x36 
  87:xcan.c        **** 
  88:xcan.c        **** #define RXB0CTRL 0x60
  89:xcan.c        **** 	#define RXM1 6
  90:xcan.c        **** 	#define RXM0 5
  91:xcan.c        **** 	#define RXRTR 3
  92:xcan.c        **** 	// Bits 2:0 FILHIT2:0
  93:xcan.c        **** #define RXB0SIDH 0x61
  94:xcan.c        **** #define RXB0SIDL 0x62
  95:xcan.c        **** #define RXB0EID8 0x63
  96:xcan.c        **** #define RXB0EID0 0x64
  97:xcan.c        **** #define RXB0DLC 0x65
  98:xcan.c        **** #define RXB0D0 0x66 
  99:xcan.c        **** 
 100:xcan.c        **** //Command Bytes
 101:xcan.c        **** #define RESET 0xC0
 102:xcan.c        **** #define READ 0x03
 103:xcan.c        **** #define READ_RX_BUFFER 0x90
 104:xcan.c        **** #define WRITE 0x02
 105:xcan.c        **** #define LOAD_TX_BUFFER 0x40
 106:xcan.c        **** #define RTS 0x80
 107:xcan.c        **** #define READ_STATUS 0xA0
 108:xcan.c        **** #define RX_STATUS 0xB0
 109:xcan.c        **** #define BIT_MODIFY 0x05
 110:xcan.c        **** 
 111:xcan.c        **** // ******************** Global Variables ***************************************
 112:xcan.c        **** static Mutex tx_mutex, rx_mutex;
 113:xcan.c        **** 
 114:xcan.c        **** //this is the buffer for received messages. 
 115:xcan.c        **** //can_get() overwrites this buffer when called
 116:xcan.c        **** can_message_t rx_msg;
 117:xcan.c        **** 
 118:xcan.c        **** //packets to be sent are queued here
 119:xcan.c        **** //static uint8_t tx_fifo_[sizeof(can_fifo_t) + TX_SIZE * sizeof(can_message_t)];
 120:xcan.c        **** //#define tx_fifo (*((can_fifo_t*) tx_fifo_))
 121:xcan.c        **** static can_fifo_t tx_fifo;
 122:xcan.c        **** 
 123:xcan.c        **** // *************** commands for Microchip MCP2515 CAN Controller ***************
 124:xcan.c        **** void mcp_reset();
 125:xcan.c        **** void mcp_write(unsigned char reg, unsigned char data);
 126:xcan.c        **** 
 127:xcan.c        **** unsigned char mcp_read(unsigned char reg);
 128:xcan.c        **** 
 129:xcan.c        **** void mcp_bitmod(unsigned char reg, unsigned char mask, unsigned char val);
 130:xcan.c        **** unsigned char mcp_status();
 131:xcan.c        **** 
 132:xcan.c        **** unsigned char mcp_status(){
 119               	.LM1:
 120               	/* prologue: frame size=0 */
 121               	/* prologue end (size=0) */
 133:xcan.c        **** 	unsigned char d;
 134:xcan.c        **** 	spi_set_ss();
 123               	.LM2:
 124 0000 C298      		cbi 56-0x20,2
 135:xcan.c        **** 	spi_data(READ_STATUS);
 126               	.LM3:
 127 0002 80EA      		ldi r24,lo8(-96)
 128 0004 0E94 0000 		call spi_data
 136:xcan.c        **** 	d = spi_data(0);
 130               	.LM4:
 131 0008 80E0      		ldi r24,lo8(0)
 132 000a 0E94 0000 		call spi_data
 137:xcan.c        **** 	spi_clear_ss();
 134               	.LM5:
 135 000e C29A      		sbi 56-0x20,2
 138:xcan.c        **** 	return d;
 139:xcan.c        **** }
 137               	.LM6:
 138 0010 9927      		clr r25
 139               	/* epilogue: frame size=0 */
 140 0012 0895      		ret
 141               	/* epilogue end (size=1) */
 142               	/* function mcp_status size 10 (9) */
 144               	.Lscope0:
 149               	.global	mcp_bitmod
 151               	mcp_bitmod:
 140:xcan.c        **** 
 141:xcan.c        **** void mcp_bitmod(unsigned char reg, unsigned char mask, unsigned char val){
 153               	.LM7:
 154               	/* prologue: frame size=0 */
 155 0014 FF92      		push r15
 156 0016 0F93      		push r16
 157 0018 1F93      		push r17
 158               	/* prologue end (size=3) */
 159 001a 182F      		mov r17,r24
 160 001c 062F      		mov r16,r22
 161 001e F42E      		mov r15,r20
 142:xcan.c        **** 	spi_set_ss();
 163               	.LM8:
 164 0020 C298      		cbi 56-0x20,2
 143:xcan.c        **** 	spi_data(BIT_MODIFY);
 166               	.LM9:
 167 0022 85E0      		ldi r24,lo8(5)
 168 0024 0E94 0000 		call spi_data
 144:xcan.c        **** 	spi_data(reg);
 170               	.LM10:
 171 0028 812F      		mov r24,r17
 172 002a 0E94 0000 		call spi_data
 145:xcan.c        **** 	spi_data(mask);
 174               	.LM11:
 175 002e 802F      		mov r24,r16
 176 0030 0E94 0000 		call spi_data
 146:xcan.c        **** 	spi_data(val);
 178               	.LM12:
 179 0034 8F2D      		mov r24,r15
 180 0036 0E94 0000 		call spi_data
 147:xcan.c        **** 	spi_clear_ss();
 182               	.LM13:
 183 003a C29A      		sbi 56-0x20,2
 184               	/* epilogue: frame size=0 */
 185 003c 1F91      		pop r17
 186 003e 0F91      		pop r16
 187 0040 FF90      		pop r15
 188 0042 0895      		ret
 189               	/* epilogue end (size=4) */
 190               	/* function mcp_bitmod size 24 (17) */
 192               	.Lscope1:
 195               	.global	message_load
 197               	message_load:
 148:xcan.c        **** }
 149:xcan.c        **** 
 150:xcan.c        **** //load a message to mcp2515 and start transmission
 151:xcan.c        **** void message_load(can_message_t * tx_msg){
 199               	.LM14:
 200               	/* prologue: frame size=0 */
 201 0044 1F93      		push r17
 202 0046 CF93      		push r28
 203 0048 DF93      		push r29
 204               	/* prologue end (size=3) */
 205 004a EC01      		movw r28,r24
 152:xcan.c        **** 	unsigned char x;
 153:xcan.c        **** 	
 154:xcan.c        **** 	spi_set_ss();
 207               	.LM15:
 208 004c C298      		cbi 56-0x20,2
 155:xcan.c        **** 	spi_data(WRITE);
 210               	.LM16:
 211 004e 82E0      		ldi r24,lo8(2)
 212 0050 0E94 0000 		call spi_data
 156:xcan.c        **** 	spi_data(TXB0SIDH);
 214               	.LM17:
 215 0054 81E3      		ldi r24,lo8(49)
 216 0056 0E94 0000 		call spi_data
 157:xcan.c        **** 
 158:xcan.c        **** 	spi_data( ((unsigned char)(tx_msg->port_src << 2)) | (tx_msg->port_dst >> 4 ) );
 218               	.LM18:
 219 005a 9A81      		ldd r25,Y+2
 220 005c 990F      		lsl r25
 221 005e 990F      		lsl r25
 222 0060 8B81      		ldd r24,Y+3
 223 0062 8295      		swap r24
 224 0064 8F70      		andi r24,0x0f
 225 0066 892B      		or r24,r25
 226 0068 0E94 0000 		call spi_data
 159:xcan.c        **** 	spi_data( (unsigned char)((tx_msg->port_dst & 0x0C) << 3) | (1<<EXIDE) | (tx_msg->port_dst & 0x03)
 228               	.LM19:
 229 006c 9B81      		ldd r25,Y+3
 230 006e 892F      		mov r24,r25
 231 0070 8C70      		andi r24,lo8(12)
 232 0072 880F      		lsl r24
 233 0074 880F      		lsl r24
 234 0076 880F      		lsl r24
 235 0078 9370      		andi r25,lo8(3)
 236 007a 892B      		or r24,r25
 237 007c 8860      		ori r24,lo8(8)
 238 007e 0E94 0000 		call spi_data
 160:xcan.c        **** 	spi_data(tx_msg->addr_src);
 240               	.LM20:
 241 0082 8881      		ld r24,Y
 242 0084 0E94 0000 		call spi_data
 161:xcan.c        **** 	spi_data(tx_msg->addr_dst);
 244               	.LM21:
 245 0088 8981      		ldd r24,Y+1
 246 008a 0E94 0000 		call spi_data
 162:xcan.c        **** 	spi_data(tx_msg->dlc);
 248               	.LM22:
 249 008e 8C81      		ldd r24,Y+4
 250 0090 0E94 0000 		call spi_data
 163:xcan.c        **** 	for(x=0;x<tx_msg->dlc;x++){
 252               	.LM23:
 253 0094 10E0      		ldi r17,lo8(0)
 254               	.L10:
 256               	.LM24:
 257 0096 8C81      		ldd r24,Y+4
 258 0098 1817      		cp r17,r24
 259 009a 40F4      		brsh .L9
 164:xcan.c        **** 		spi_data(tx_msg->data[x]);
 261               	.LM25:
 262 009c FE01      		movw r30,r28
 263 009e E10F      		add r30,r17
 264 00a0 F11D      		adc r31,__zero_reg__
 265 00a2 8581      		ldd r24,Z+5
 266 00a4 0E94 0000 		call spi_data
 268               	.LM26:
 269 00a8 1F5F      		subi r17,lo8(-(1))
 270 00aa F5CF      		rjmp .L10
 271               	.L9:
 165:xcan.c        **** 	}
 166:xcan.c        **** 	spi_clear_ss();
 273               	.LM27:
 274 00ac C29A      		sbi 56-0x20,2
 167:xcan.c        **** 	spi_set_ss();
 276               	.LM28:
 277 00ae C298      		cbi 56-0x20,2
 168:xcan.c        **** 	spi_data(WRITE);
 279               	.LM29:
 280 00b0 82E0      		ldi r24,lo8(2)
 281 00b2 0E94 0000 		call spi_data
 169:xcan.c        **** 	spi_data(TXB0CTRL);
 283               	.LM30:
 284 00b6 80E3      		ldi r24,lo8(48)
 285 00b8 0E94 0000 		call spi_data
 170:xcan.c        **** 	spi_data( (1<<TXREQ) );
 287               	.LM31:
 288 00bc 88E0      		ldi r24,lo8(8)
 289 00be 0E94 0000 		call spi_data
 171:xcan.c        **** 	spi_clear_ss();
 291               	.LM32:
 292 00c2 C29A      		sbi 56-0x20,2
 293               	/* epilogue: frame size=0 */
 294 00c4 DF91      		pop r29
 295 00c6 CF91      		pop r28
 296 00c8 1F91      		pop r17
 297 00ca 0895      		ret
 298               	/* epilogue end (size=4) */
 299               	/* function message_load size 68 (61) */
 304               	.Lscope2:
 306               	.global	message_fetch
 308               	message_fetch:
 172:xcan.c        **** }
 173:xcan.c        **** 
 174:xcan.c        **** //get a message from mcp2515 and disable RX interrupt Condition
 175:xcan.c        **** void message_fetch(){
 310               	.LM33:
 311               	/* prologue: frame size=0 */
 312 00cc 0F93      		push r16
 313 00ce 1F93      		push r17
 314 00d0 CF93      		push r28
 315               	/* prologue end (size=3) */
 176:xcan.c        **** 	unsigned char tmp1, tmp2, tmp3;
 177:xcan.c        **** 	unsigned char x;
 178:xcan.c        **** 
 179:xcan.c        **** 	spi_set_ss();
 317               	.LM34:
 318 00d2 C298      		cbi 56-0x20,2
 180:xcan.c        **** 	spi_data(READ);
 320               	.LM35:
 321 00d4 83E0      		ldi r24,lo8(3)
 322 00d6 0E94 0000 		call spi_data
 181:xcan.c        **** 	spi_data(RXB0SIDH);
 324               	.LM36:
 325 00da 81E6      		ldi r24,lo8(97)
 326 00dc 0E94 0000 		call spi_data
 182:xcan.c        **** 	tmp1 = spi_data(0);
 328               	.LM37:
 329 00e0 80E0      		ldi r24,lo8(0)
 330 00e2 0E94 0000 		call spi_data
 331 00e6 182F      		mov r17,r24
 183:xcan.c        **** 	rx_msg.port_src = tmp1 >> 2;
 333               	.LM38:
 334 00e8 8695      		lsr r24
 335 00ea 8695      		lsr r24
 336 00ec 8093 0000 		sts rx_msg+2,r24
 184:xcan.c        **** 	tmp2 = spi_data(0);
 338               	.LM39:
 339 00f0 80E0      		ldi r24,lo8(0)
 340 00f2 0E94 0000 		call spi_data
 341 00f6 982F      		mov r25,r24
 185:xcan.c        **** 	tmp3 = (unsigned char)((unsigned char)(tmp2 >> 3) & 0x0C);
 343               	.LM40:
 344 00f8 8695      		lsr r24
 345 00fa 8695      		lsr r24
 346 00fc 8695      		lsr r24
 347 00fe 8C70      		andi r24,lo8(12)
 186:xcan.c        **** 	rx_msg.port_dst = ((unsigned char)(tmp1 <<4 ) & 0x30) | tmp3 | (unsigned char)(tmp2 & 0x03);
 349               	.LM41:
 350 0100 1295      		swap r17
 351 0102 107F      		andi r17,0xf0
 352 0104 1073      		andi r17,lo8(48)
 353 0106 182B      		or r17,r24
 354 0108 9370      		andi r25,lo8(3)
 355 010a 192B      		or r17,r25
 356 010c 1093 0000 		sts rx_msg+3,r17
 187:xcan.c        **** 	rx_msg.addr_src = spi_data(0);
 358               	.LM42:
 359 0110 80E0      		ldi r24,lo8(0)
 360 0112 0E94 0000 		call spi_data
 361 0116 8093 0000 		sts rx_msg,r24
 188:xcan.c        **** 	rx_msg.addr_dst = spi_data(0);
 363               	.LM43:
 364 011a 80E0      		ldi r24,lo8(0)
 365 011c 0E94 0000 		call spi_data
 366 0120 8093 0000 		sts rx_msg+1,r24
 189:xcan.c        **** 	rx_msg.dlc = spi_data(0) & 0x0F;	
 368               	.LM44:
 369 0124 80E0      		ldi r24,lo8(0)
 370 0126 0E94 0000 		call spi_data
 371 012a 8F70      		andi r24,lo8(15)
 372 012c 8093 0000 		sts rx_msg+4,r24
 190:xcan.c        **** 	for(x=0;x<rx_msg.dlc;x++){
 374               	.LM45:
 375 0130 C0E0      		ldi r28,lo8(0)
 376               	.L18:
 378               	.LM46:
 379 0132 C817      		cp r28,r24
 380 0134 68F4      		brsh .L17
 191:xcan.c        **** 		rx_msg.data[x] = spi_data(0);
 382               	.LM47:
 383 0136 0C2F      		mov r16,r28
 384 0138 1127      		clr r17
 385 013a 0050      		subi r16,lo8(-(rx_msg))
 386 013c 1040      		sbci r17,hi8(-(rx_msg))
 387 013e 80E0      		ldi r24,lo8(0)
 388 0140 0E94 0000 		call spi_data
 389 0144 F801      		movw r30,r16
 390 0146 8583      		std Z+5,r24
 392               	.LM48:
 393 0148 CF5F      		subi r28,lo8(-(1))
 394 014a 8091 0000 		lds r24,rx_msg+4
 395 014e F1CF      		rjmp .L18
 396               	.L17:
 192:xcan.c        **** 	}
 193:xcan.c        **** 	spi_clear_ss();
 398               	.LM49:
 399 0150 C29A      		sbi 56-0x20,2
 194:xcan.c        **** 	
 195:xcan.c        **** 	mcp_bitmod(CANINTF, (1<<RX0IF), 0x00);
 401               	.LM50:
 402 0152 40E0      		ldi r20,lo8(0)
 403 0154 61E0      		ldi r22,lo8(1)
 404 0156 8CE2      		ldi r24,lo8(44)
 405 0158 0E94 0000 		call mcp_bitmod
 406               	/* epilogue: frame size=0 */
 407 015c CF91      		pop r28
 408 015e 1F91      		pop r17
 409 0160 0F91      		pop r16
 410 0162 0895      		ret
 411               	/* epilogue end (size=4) */
 412               	/* function message_fetch size 76 (69) */
 419               	.Lscope3:
 421               	.global	__vector_1
 423               	__vector_1:
 196:xcan.c        **** }
 197:xcan.c        **** 
 198:xcan.c        **** 
 199:xcan.c        **** // *********************** Interrupt handler  **********************************
 200:xcan.c        **** AVRX_SIGINT(SIG_INTERRUPT0)
 201:xcan.c        **** {
 425               	.LM51:
 426               	/* prologue: frame size=0 */
 427               	/* prologue: naked */
 428               	/* prologue end (size=0) */
 202:xcan.c        **** 	IntProlog();             // Switch to kernel stack/context
 430               	.LM52:
 431 0164 0E94 0000 		call IntProlog
 203:xcan.c        **** 	GICR &= ~(1<<INT0);
 433               	.LM53:
 434 0168 8BB7      		in r24,91-0x20
 435 016a 8F7B      		andi r24,lo8(-65)
 436 016c 8BBF      		out 91-0x20,r24
 204:xcan.c        **** 	EndCritical();
 438               	.LM54:
 439               	/* #APP */
 440 016e 7894      		sei
 441               	
 205:xcan.c        **** 	unsigned char status = mcp_status();
 443               	.LM55:
 444               	/* #NOAPP */
 445 0170 0E94 0000 		call mcp_status
 206:xcan.c        **** 
 207:xcan.c        **** 	if ( status & 0x01 ) {	// Message in RX0
 447               	.LM56:
 448 0174 9927      		clr r25
 449 0176 80FF      		sbrs r24,0
 450 0178 08C0      		rjmp .L20
 208:xcan.c        **** 		mcp_bitmod(CANINTE, (1<<RX0IE), 0x00); //disable interrupt
 452               	.LM57:
 453 017a 40E0      		ldi r20,lo8(0)
 454 017c 61E0      		ldi r22,lo8(1)
 455 017e 8BE2      		ldi r24,lo8(43)
 456 0180 0E94 0000 		call mcp_bitmod
 209:xcan.c        **** 		AvrXIntSetSemaphore(&rx_mutex);
 458               	.LM58:
 459 0184 80E0      		ldi r24,lo8(rx_mutex)
 460 0186 90E0      		ldi r25,hi8(rx_mutex)
 461 0188 27C0      		rjmp .L26
 462               	.L20:
 210:xcan.c        **** 	} else if ( status & 0x08 ) {	// TX0 empty
 464               	.LM59:
 465 018a 83FF      		sbrs r24,3
 466 018c 27C0      		rjmp .L21
 211:xcan.c        **** 		if (tx_fifo.in == tx_fifo.out)	// tx_fifo is Empty
 468               	.LM60:
 469 018e 8091 0000 		lds r24,tx_fifo
 470 0192 9091 0000 		lds r25,tx_fifo+1
 471 0196 8917      		cp r24,r25
 472 0198 31F4      		brne .L23
 212:xcan.c        **** 		{
 213:xcan.c        **** 			mcp_bitmod(CANINTE, (1<<TX0IE), 0x00); //disable interrupt
 474               	.LM61:
 475 019a 40E0      		ldi r20,lo8(0)
 476 019c 64E0      		ldi r22,lo8(4)
 477 019e 8BE2      		ldi r24,lo8(43)
 478 01a0 0E94 0000 		call mcp_bitmod
 479 01a4 1BC0      		rjmp .L21
 480               	.L23:
 481               	.LBB2:
 214:xcan.c        **** 		}
 215:xcan.c        **** 		else
 216:xcan.c        **** 		{
 217:xcan.c        **** 			//Pull can message from fifo and transmit it
 218:xcan.c        **** 			message_load (&tx_fifo.buf[tx_fifo.out]);
 483               	.LM62:
 484 01a6 8DE0      		ldi r24,lo8(13)
 485 01a8 989F      		mul r25,r24
 486 01aa C001      		movw r24,r0
 487 01ac 1124      		clr r1
 488 01ae 8050      		subi r24,lo8(-(tx_fifo+3))
 489 01b0 9040      		sbci r25,hi8(-(tx_fifo+3))
 490 01b2 0E94 0000 		call message_load
 219:xcan.c        **** 			uint8_t t = tx_fifo.out+1;
 492               	.LM63:
 493 01b6 9091 0000 		lds r25,tx_fifo+1
 494 01ba 9F5F      		subi r25,lo8(-(1))
 220:xcan.c        **** 			if (t >= tx_fifo.size)
 496               	.LM64:
 497 01bc 8091 0000 		lds r24,tx_fifo+2
 498 01c0 9817      		cp r25,r24
 499 01c2 08F0      		brlo .L25
 221:xcan.c        **** 				t = 0;
 501               	.LM65:
 502 01c4 90E0      		ldi r25,lo8(0)
 503               	.L25:
 222:xcan.c        **** 			tx_fifo.out = t;
 505               	.LM66:
 506 01c6 9093 0000 		sts tx_fifo+1,r25
 223:xcan.c        **** 			mcp_bitmod(CANINTF, (1<<TX0IF), 0x00); //clear interrupt condition
 508               	.LM67:
 509 01ca 40E0      		ldi r20,lo8(0)
 510 01cc 64E0      		ldi r22,lo8(4)
 511 01ce 8CE2      		ldi r24,lo8(44)
 512 01d0 0E94 0000 		call mcp_bitmod
 224:xcan.c        **** 			AvrXIntSetSemaphore(&tx_mutex); //Signal were ready for new messages
 514               	.LM68:
 515 01d4 80E0      		ldi r24,lo8(tx_mutex)
 516 01d6 90E0      		ldi r25,hi8(tx_mutex)
 517               	.L26:
 518 01d8 0E94 0000 		call AvrXIntSetSemaphore
 519               	.L21:
 520               	.LBE2:
 225:xcan.c        **** 		}
 226:xcan.c        **** 	}
 227:xcan.c        **** 	GICR |= (1<<INT0);
 522               	.LM69:
 523 01dc 8BB7      		in r24,91-0x20
 524 01de 8064      		ori r24,lo8(64)
 525 01e0 8BBF      		out 91-0x20,r24
 228:xcan.c        **** 	Epilog();                // Return to tasks
 527               	.LM70:
 528 01e2 0E94 0000 		call Epilog
 529               	/* epilogue: frame size=0 */
 530               	/* epilogue: naked */
 531               	/* epilogue end (size=0) */
 532               	/* function __vector_1 size 68 (68) */
 537               	.Lscope4:
 539               	.global	mcp_reset
 541               	mcp_reset:
 229:xcan.c        **** }
 230:xcan.c        **** 
 231:xcan.c        **** void mcp_reset(){
 543               	.LM71:
 544               	/* prologue: frame size=0 */
 545               	/* prologue end (size=0) */
 232:xcan.c        **** 	spi_set_ss();
 547               	.LM72:
 548 01e6 C298      		cbi 56-0x20,2
 233:xcan.c        **** 	spi_data(RESET);
 550               	.LM73:
 551 01e8 80EC      		ldi r24,lo8(-64)
 552 01ea 0E94 0000 		call spi_data
 234:xcan.c        **** 	spi_clear_ss();
 554               	.LM74:
 555 01ee C29A      		sbi 56-0x20,2
 556               	/* epilogue: frame size=0 */
 557 01f0 0895      		ret
 558               	/* epilogue end (size=1) */
 559               	/* function mcp_reset size 6 (5) */
 561               	.Lscope5:
 565               	.global	mcp_write
 567               	mcp_write:
 235:xcan.c        **** }
 236:xcan.c        **** 
 237:xcan.c        **** void mcp_write(unsigned char reg, unsigned char data){
 569               	.LM75:
 570               	/* prologue: frame size=0 */
 571 01f2 0F93      		push r16
 572 01f4 1F93      		push r17
 573               	/* prologue end (size=2) */
 574 01f6 182F      		mov r17,r24
 575 01f8 062F      		mov r16,r22
 238:xcan.c        **** 	spi_set_ss();
 577               	.LM76:
 578 01fa C298      		cbi 56-0x20,2
 239:xcan.c        **** 	spi_data(WRITE);
 580               	.LM77:
 581 01fc 82E0      		ldi r24,lo8(2)
 582 01fe 0E94 0000 		call spi_data
 240:xcan.c        **** 	spi_data(reg);
 584               	.LM78:
 585 0202 812F      		mov r24,r17
 586 0204 0E94 0000 		call spi_data
 241:xcan.c        **** 	spi_data(data);
 588               	.LM79:
 589 0208 802F      		mov r24,r16
 590 020a 0E94 0000 		call spi_data
 242:xcan.c        **** 	spi_clear_ss();
 592               	.LM80:
 593 020e C29A      		sbi 56-0x20,2
 594               	/* epilogue: frame size=0 */
 595 0210 1F91      		pop r17
 596 0212 0F91      		pop r16
 597 0214 0895      		ret
 598               	/* epilogue end (size=3) */
 599               	/* function mcp_write size 18 (13) */
 601               	.Lscope6:
 604               	.global	mcp_read
 606               	mcp_read:
 243:xcan.c        **** }
 244:xcan.c        **** 
 245:xcan.c        **** unsigned char mcp_read(unsigned char reg){
 608               	.LM81:
 609               	/* prologue: frame size=0 */
 610 0216 1F93      		push r17
 611               	/* prologue end (size=1) */
 612 0218 182F      		mov r17,r24
 246:xcan.c        **** 	unsigned char d;
 247:xcan.c        **** 	spi_set_ss();
 614               	.LM82:
 615 021a C298      		cbi 56-0x20,2
 248:xcan.c        **** 	spi_data(READ);
 617               	.LM83:
 618 021c 83E0      		ldi r24,lo8(3)
 619 021e 0E94 0000 		call spi_data
 249:xcan.c        **** 	spi_data(reg);
 621               	.LM84:
 622 0222 812F      		mov r24,r17
 623 0224 0E94 0000 		call spi_data
 250:xcan.c        **** 	d = spi_data(0);
 625               	.LM85:
 626 0228 80E0      		ldi r24,lo8(0)
 627 022a 0E94 0000 		call spi_data
 251:xcan.c        **** 	spi_clear_ss();
 629               	.LM86:
 630 022e C29A      		sbi 56-0x20,2
 252:xcan.c        **** 	return d;
 253:xcan.c        **** }
 632               	.LM87:
 633 0230 9927      		clr r25
 634               	/* epilogue: frame size=0 */
 635 0232 1F91      		pop r17
 636 0234 0895      		ret
 637               	/* epilogue end (size=2) */
 638               	/* function mcp_read size 16 (13) */
 640               	.Lscope7:
 643               	.global	can_setmode
 645               	can_setmode:
 254:xcan.c        **** 
 255:xcan.c        **** /* Management */
 256:xcan.c        **** void can_setmode( can_mode_t mode ) {
 647               	.LM88:
 648               	/* prologue: frame size=0 */
 649               	/* prologue end (size=0) */
 257:xcan.c        **** 	unsigned char val = mode << 5;  
 651               	.LM89:
 652 0236 8295      		swap r24
 653 0238 880F      		lsl r24
 654 023a 807E      		andi r24,0xe0
 258:xcan.c        **** 	val |= 0x04;  // CLKEN
 656               	.LM90:
 657 023c 8460      		ori r24,lo8(4)
 259:xcan.c        **** 
 260:xcan.c        **** 	mcp_write( CANCTRL, val );
 659               	.LM91:
 660 023e 682F      		mov r22,r24
 661 0240 8FE0      		ldi r24,lo8(15)
 662 0242 0E94 0000 		call mcp_write
 663               	/* epilogue: frame size=0 */
 664 0246 0895      		ret
 665               	/* epilogue end (size=1) */
 666               	/* function can_setmode size 9 (8) */
 671               	.Lscope8:
 673               	.global	can_setfilter
 675               	can_setfilter:
 261:xcan.c        **** }
 262:xcan.c        **** 
 263:xcan.c        **** void can_setfilter() {
 677               	.LM92:
 678               	/* prologue: frame size=0 */
 679               	/* prologue end (size=0) */
 264:xcan.c        **** 	//RXM1   RXM0
 265:xcan.c        **** 	//  0      0     receive matching filter
 266:xcan.c        **** 	//  0      1     " only 11bit Identifier
 267:xcan.c        **** 	//  1      0     " only 29bit Identifier
 268:xcan.c        **** 	//  1      1     any
 269:xcan.c        **** 	mcp_write(RXB0CTRL, (1<<RXM1) | (1<<RXM0));
 681               	.LM93:
 682 0248 60E6      		ldi r22,lo8(96)
 683 024a 862F      		mov r24,r22
 684 024c 0E94 0000 		call mcp_write
 685               	/* epilogue: frame size=0 */
 686 0250 0895      		ret
 687               	/* epilogue end (size=1) */
 688               	/* function can_setfilter size 5 (4) */
 690               	.Lscope9:
 694               	.global	can_setled
 696               	can_setled:
 270:xcan.c        **** }
 271:xcan.c        **** 
 272:xcan.c        **** void can_setled(unsigned char led, unsigned char state){
 698               	.LM94:
 699               	/* prologue: frame size=0 */
 700               	/* prologue end (size=0) */
 701 0252 282F      		mov r18,r24
 702 0254 462F      		mov r20,r22
 273:xcan.c        **** 	mcp_bitmod(BFPCTRL, 0x10<<led, state?0xff:0);
 704               	.LM95:
 705 0256 6111      		cpse r22,__zero_reg__
 707               	.LM96:
 708 0258 4FEF      		ldi r20,lo8(-1)
 709               	.L34:
 710 025a 80E1      		ldi r24,lo8(16)
 711 025c 90E0      		ldi r25,hi8(16)
 712 025e 02C0      		rjmp 2f
 713 0260 880F      	1:	lsl r24
 714 0262 991F      		rol r25
 715 0264 2A95      	2:	dec r18
 716 0266 E2F7      		brpl 1b
 717 0268 682F      		mov r22,r24
 718 026a 8CE0      		ldi r24,lo8(12)
 719 026c 0E94 0000 		call mcp_bitmod
 720               	/* epilogue: frame size=0 */
 721 0270 0895      		ret
 722               	/* epilogue end (size=1) */
 723               	/* function can_setled size 18 (17) */
 725               	.Lscope10:
 727               	.global	delayloop
 729               	delayloop:
 274:xcan.c        **** }
 275:xcan.c        **** 
 276:xcan.c        **** /*******************************************************************/
 277:xcan.c        **** void delayloop(){
 731               	.LM97:
 732               	/* prologue: frame size=0 */
 733               	/* prologue end (size=0) */
 278:xcan.c        **** 	unsigned char x;
 279:xcan.c        **** 	for(x=0;x<255;x++){		
 735               	.LM98:
 736 0272 80E0      		ldi r24,lo8(0)
 737               	.L39:
 280:xcan.c        **** 		asm ("nop");
 739               	.LM99:
 740               	/* #APP */
 741 0274 0000      		nop
 743               	.LM100:
 744               	/* #NOAPP */
 745 0276 8F5F      		subi r24,lo8(-(1))
 746 0278 8F3F      		cpi r24,lo8(-1)
 747 027a E1F7      		brne .L39
 748               	/* epilogue: frame size=0 */
 749 027c 0895      		ret
 750               	/* epilogue end (size=1) */
 751               	/* function delayloop size 7 (6) */
 756               	.Lscope11:
 758               	.global	can_init
 760               	can_init:
 281:xcan.c        **** 	}
 282:xcan.c        **** 
 283:xcan.c        **** }
 284:xcan.c        **** 
 285:xcan.c        **** void can_init(){
 762               	.LM101:
 763               	/* prologue: frame size=0 */
 764               	/* prologue end (size=0) */
 286:xcan.c        **** 	//set Slave select high
 287:xcan.c        **** 	SPI_PORT |= (1<<SPI_PIN_SS);
 766               	.LM102:
 767 027e C29A      		sbi 56-0x20,2
 288:xcan.c        **** 	
 289:xcan.c        **** 	mcp_reset();
 769               	.LM103:
 770 0280 0E94 0000 		call mcp_reset
 290:xcan.c        **** 	
 291:xcan.c        **** 	tx_fifo.size = TX_SIZE;
 772               	.LM104:
 773 0284 8AE0      		ldi r24,lo8(10)
 774 0286 8093 0000 		sts tx_fifo+2,r24
 292:xcan.c        **** 	tx_fifo.in = 0;
 776               	.LM105:
 777 028a 1092 0000 		sts tx_fifo,__zero_reg__
 293:xcan.c        **** 	tx_fifo.out = 0;
 779               	.LM106:
 780 028e 1092 0000 		sts tx_fifo+1,__zero_reg__
 294:xcan.c        **** 	
 295:xcan.c        **** 	AvrXResetSemaphore(&rx_mutex);
 782               	.LM107:
 783 0292 80E0      		ldi r24,lo8(rx_mutex)
 784 0294 90E0      		ldi r25,hi8(rx_mutex)
 785 0296 0E94 0000 		call AvrXResetSemaphore
 296:xcan.c        **** 	
 297:xcan.c        **** 	delayloop();
 787               	.LM108:
 788 029a 0E94 0000 		call delayloop
 298:xcan.c        **** 	
 299:xcan.c        **** 	mcp_write(BFPCTRL,0x0C);//RXBF Pins to Output
 790               	.LM109:
 791 029e 6CE0      		ldi r22,lo8(12)
 792 02a0 862F      		mov r24,r22
 793 02a2 0E94 0000 		call mcp_write
 300:xcan.c        **** 	
 301:xcan.c        **** 	// 0x01 : 125kbit/8MHz
 302:xcan.c        **** 	// 0x03 : 125kbit/16MHz
 303:xcan.c        **** 	// 0x04 : 125kbit/20MHz
 304:xcan.c        **** 	
 305:xcan.c        **** #	if F_MCP == 16000000L
 306:xcan.c        **** #	define CNF1_T 0x03
 307:xcan.c        **** #	elif F_MCP == 8000000L
 308:xcan.c        **** #	define CNF1_T 0x01
 309:xcan.c        **** #	elif F_MCP == 20000000L
 310:xcan.c        **** #	define CNF1_T 0x04
 311:xcan.c        **** #	else
 312:xcan.c        **** #	error Can Baudrate is only defined for F_MCP 8, 16 and 20 MHz
 313:xcan.c        **** #	endif
 314:xcan.c        **** 
 315:xcan.c        **** 	mcp_write( CNF1, 0x40 | CNF1_T );
 795               	.LM110:
 796 02a6 63E4      		ldi r22,lo8(67)
 797 02a8 8AE2      		ldi r24,lo8(42)
 798 02aa 0E94 0000 		call mcp_write
 316:xcan.c        **** 	mcp_write( CNF2, 0xf1 );
 800               	.LM111:
 801 02ae 61EF      		ldi r22,lo8(-15)
 802 02b0 89E2      		ldi r24,lo8(41)
 803 02b2 0E94 0000 		call mcp_write
 317:xcan.c        **** 	mcp_write( CNF3, 0x05 );
 805               	.LM112:
 806 02b6 65E0      		ldi r22,lo8(5)
 807 02b8 88E2      		ldi r24,lo8(40)
 808 02ba 0E94 0000 		call mcp_write
 318:xcan.c        **** 
 319:xcan.c        **** 	// configure IRQ
 320:xcan.c        **** 	// this only configures the INT Output of the mcp2515, not the int on the Atmel
 321:xcan.c        **** 	mcp_write( CANINTE, (1<<RX0IE) );
 810               	.LM113:
 811 02be 61E0      		ldi r22,lo8(1)
 812 02c0 8BE2      		ldi r24,lo8(43)
 813 02c2 0E94 0000 		call mcp_write
 322:xcan.c        **** 
 323:xcan.c        **** 	//the TX Interrupt is enabled when needed, so set flag that buffer is empty
 324:xcan.c        **** 	mcp_bitmod( CANINTF, (1<<TX0IF), 0xff );
 815               	.LM114:
 816 02c6 4FEF      		ldi r20,lo8(-1)
 817 02c8 64E0      		ldi r22,lo8(4)
 818 02ca 8CE2      		ldi r24,lo8(44)
 819 02cc 0E94 0000 		call mcp_bitmod
 325:xcan.c        **** 
 326:xcan.c        **** 	can_setfilter();
 821               	.LM115:
 822 02d0 0E94 0000 		call can_setfilter
 327:xcan.c        **** 	can_setmode(normal);
 824               	.LM116:
 825 02d4 80E0      		ldi r24,lo8(0)
 826 02d6 0E94 0000 		call can_setmode
 328:xcan.c        **** 
 329:xcan.c        **** #ifdef CLASSIC_ATMEL
 330:xcan.c        **** 	//this turns on INT0 on the Atmel
 331:xcan.c        **** 	MCUCR |=  (1<<ISC01);
 332:xcan.c        **** 	GIMSK |= (1<<INT0);
 333:xcan.c        **** #else
 334:xcan.c        **** 	//this turns on INT0 on the Atmega
 335:xcan.c        **** 	//MCUCR |=  (1<<ISC01);
 336:xcan.c        **** 	GICR |= (1<<INT0);
 828               	.LM117:
 829 02da 8BB7      		in r24,91-0x20
 830 02dc 8064      		ori r24,lo8(64)
 831 02de 8BBF      		out 91-0x20,r24
 832               	/* epilogue: frame size=0 */
 833 02e0 0895      		ret
 834               	/* epilogue end (size=1) */
 835               	/* function can_init size 50 (49) */
 837               	.Lscope12:
 839               	.global	can_get
 841               	can_get:
 337:xcan.c        **** #endif
 338:xcan.c        **** 
 339:xcan.c        **** }
 340:xcan.c        **** 
 341:xcan.c        **** void can_get(){
 843               	.LM118:
 844               	/* prologue: frame size=0 */
 845               	/* prologue end (size=0) */
 342:xcan.c        **** 	AvrXWaitSemaphore(&rx_mutex);
 847               	.LM119:
 848 02e2 80E0      		ldi r24,lo8(rx_mutex)
 849 02e4 90E0      		ldi r25,hi8(rx_mutex)
 850 02e6 0E94 0000 		call AvrXWaitSemaphore
 343:xcan.c        **** 	message_fetch();
 852               	.LM120:
 853 02ea 0E94 0000 		call message_fetch
 344:xcan.c        **** 	mcp_bitmod( CANINTE, (1<<RX0IE), 0xff); //interrupt back on
 855               	.LM121:
 856 02ee 4FEF      		ldi r20,lo8(-1)
 857 02f0 61E0      		ldi r22,lo8(1)
 858 02f2 8BE2      		ldi r24,lo8(43)
 859 02f4 0E94 0000 		call mcp_bitmod
 860               	/* epilogue: frame size=0 */
 861 02f8 0895      		ret
 862               	/* epilogue end (size=1) */
 863               	/* function can_get size 12 (11) */
 865               	.Lscope13:
 868               	.global	can_put
 870               	can_put:
 345:xcan.c        **** }
 346:xcan.c        **** 
 347:xcan.c        **** uint16_t can_put(can_message_t * msg){
 872               	.LM122:
 873               	/* prologue: frame size=0 */
 874               	/* prologue end (size=0) */
 875 02fa BC01      		movw r22,r24
 348:xcan.c        **** 	uint8_t t = tx_fifo.in+1;
 877               	.LM123:
 878 02fc 2091 0000 		lds r18,tx_fifo
 879 0300 422F      		mov r20,r18
 880 0302 4F5F      		subi r20,lo8(-(1))
 349:xcan.c        **** 	if (t >= tx_fifo.size)
 882               	.LM124:
 883 0304 8091 0000 		lds r24,tx_fifo+2
 884 0308 4817      		cp r20,r24
 885 030a 08F0      		brlo .L45
 350:xcan.c        **** 		t = 0;
 887               	.LM125:
 888 030c 40E0      		ldi r20,lo8(0)
 889               	.L45:
 351:xcan.c        **** 	if (t == tx_fifo.out)	// isFull()
 891               	.LM126:
 892 030e 8091 0000 		lds r24,tx_fifo+1
 893 0312 4817      		cp r20,r24
 894 0314 19F4      		brne .L46
 352:xcan.c        **** 		return FIFO_ERR;
 896               	.LM127:
 897 0316 8FEF      		ldi r24,lo8(-1)
 898 0318 9FEF      		ldi r25,hi8(-1)
 899 031a 0895      		ret
 900               	.L46:
 353:xcan.c        **** 	memcpy (&tx_fifo.buf[tx_fifo.in], msg, sizeof(can_message_t));
 902               	.LM128:
 903 031c 3327      		clr r19
 904 031e 8DE0      		ldi r24,lo8(13)
 905 0320 90E0      		ldi r25,hi8(13)
 906 0322 289F      		mul r18,r24
 907 0324 F001      		movw r30,r0
 908 0326 299F      		mul r18,r25
 909 0328 F00D      		add r31,r0
 910 032a 389F      		mul r19,r24
 911 032c F00D      		add r31,r0
 912 032e 1124      		clr r1
 913 0330 E050      		subi r30,lo8(-(tx_fifo+3))
 914 0332 F040      		sbci r31,hi8(-(tx_fifo+3))
 915 0334 DB01      		movw r26,r22
 916 0336 8DE0      		ldi r24,lo8(13)
 917               	.L47:
 918 0338 0D90      		ld r0,X+
 919 033a 0192      		st Z+,r0
 920 033c 8150      		subi r24,lo8(-(-1))
 921 033e E1F7      		brne .L47
 354:xcan.c        **** 	tx_fifo.in = t;
 923               	.LM129:
 924 0340 4093 0000 		sts tx_fifo,r20
 355:xcan.c        **** 	//AvrXSetSemaphore(&p->Producer);
 356:xcan.c        **** 	GICR &= ~(1<<INT0);
 926               	.LM130:
 927 0344 8BB7      		in r24,91-0x20
 928 0346 8F7B      		andi r24,lo8(-65)
 929 0348 8BBF      		out 91-0x20,r24
 357:xcan.c        **** 	mcp_bitmod(CANINTE, (1<<TX0IE), 0xff); //enable interrupt
 931               	.LM131:
 932 034a 4FEF      		ldi r20,lo8(-1)
 933 034c 64E0      		ldi r22,lo8(4)
 934 034e 8BE2      		ldi r24,lo8(43)
 935 0350 0E94 0000 		call mcp_bitmod
 358:xcan.c        **** 	GICR |= (1<<INT0);
 937               	.LM132:
 938 0354 8BB7      		in r24,91-0x20
 939 0356 8064      		ori r24,lo8(64)
 940 0358 8BBF      		out 91-0x20,r24
 359:xcan.c        **** 	return FIFO_OK;
 942               	.LM133:
 943 035a 80E0      		ldi r24,lo8(0)
 944 035c 90E0      		ldi r25,hi8(0)
 360:xcan.c        **** }
 946               	.LM134:
 947 035e 0895      		ret
 948               	/* epilogue: frame size=0 */
 949               	/* epilogue: noreturn */
 950               	/* epilogue end (size=0) */
 951               	/* function can_put size 52 (52) */
 956               	.Lscope14:
 957               		.comm rx_msg,13,1
 958               		.lcomm tx_mutex,2
 959               		.lcomm rx_mutex,2
 960               		.lcomm tx_fifo,133
 965               		.text
 967               	Letext:
 968               	/* File "xcan.c": code  439 = 0x01b7 ( 402), prologues  12, epilogues  25 */
DEFINED SYMBOLS
                            *ABS*:00000000 xcan.c
     /tmp/ccZe4kNd.s:3      *ABS*:0000003f __SREG__
     /tmp/ccZe4kNd.s:4      *ABS*:0000003e __SP_H__
     /tmp/ccZe4kNd.s:5      *ABS*:0000003d __SP_L__
     /tmp/ccZe4kNd.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccZe4kNd.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccZe4kNd.s:117    .text:00000000 mcp_status
     /tmp/ccZe4kNd.s:151    .text:00000014 mcp_bitmod
     /tmp/ccZe4kNd.s:197    .text:00000044 message_load
     /tmp/ccZe4kNd.s:308    .text:000000cc message_fetch
                            *COM*:0000000d rx_msg
     /tmp/ccZe4kNd.s:423    .text:00000164 __vector_1
     /tmp/ccZe4kNd.s:958    .bss:00000002 rx_mutex
     /tmp/ccZe4kNd.s:959    .bss:00000004 tx_fifo
                             .bss:00000000 tx_mutex
     /tmp/ccZe4kNd.s:541    .text:000001e6 mcp_reset
     /tmp/ccZe4kNd.s:567    .text:000001f2 mcp_write
     /tmp/ccZe4kNd.s:606    .text:00000216 mcp_read
     /tmp/ccZe4kNd.s:645    .text:00000236 can_setmode
     /tmp/ccZe4kNd.s:675    .text:00000248 can_setfilter
     /tmp/ccZe4kNd.s:696    .text:00000252 can_setled
     /tmp/ccZe4kNd.s:729    .text:00000272 delayloop
     /tmp/ccZe4kNd.s:760    .text:0000027e can_init
     /tmp/ccZe4kNd.s:841    .text:000002e2 can_get
     /tmp/ccZe4kNd.s:870    .text:000002fa can_put
     /tmp/ccZe4kNd.s:967    .text:00000360 Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
spi_data
IntProlog
AvrXIntSetSemaphore
Epilog
AvrXResetSemaphore
AvrXWaitSemaphore
