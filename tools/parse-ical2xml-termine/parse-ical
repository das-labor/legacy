#!/usr/bin/env ruby



XMLFILE="termine.xml";
NRXMLFILE="talksworkshops.xml";
ICALFILE="termine.ical";

#############################################################################
# Starts Here
require 'rubygems' 
require 'icalendar'
require 'date'


include Icalendar

class LaborTermine 
	attr_reader "termine"
	attr_reader "nrtermine"

	def initialize()
		@termine = Array.new
		@nrtermine = Array.new
	end
	
	def parse()	
		term = Array.new
		nrterm = Array.new

		cal_file = File.open(ICALFILE)
		cals = Icalendar.parse(cal_file)
		cal = cals.first
		cal.events.each{|e|
			t = Hash.new	# one hash table per event (contains date, title, link)
#			puts "Termin:"

			t["date"] = e.dtstart
#			puts e.dtstart

			t["text"] = e.summary
#			puts "Title:" + e.summary

			t["link"] = e.description
#			puts "Link:" + e.description
			term.push(t) 	# store the hash table in an global array
		}
		cal.events.each{|e|
			h = Hash.new	# one hash table per event (contains date, title, link)
#			puts "Termin:"

			h["date"] = e.dtstart
#			puts e.dtstart

			h["text"] = e.summary
#			puts "Title:" + e.summary

			h["link"] = e.description
#			puts "Link:" + e.description
            if e.recurrence_rules.to_ical == "" then
                nrterm.push(h)  # only non-recurring events
            end
		}

		thash = Hash.new
		thash["termine"] = term
		thash["nrtermine"] = nrterm
		return thash
	end
	
	def sort(tarr)		# events are not necessarily ordered by date
#		puts "Sorting by date ..."
		d = Array.new	# array to sort dates
		ttermine = Array.new 	# temp array to overwrite @termine with

		tarr.each{|t|
			d.push(t["date"])
		}
		d.sort!
#		puts "Sorting @termine by date ..."
		d.each{|da|
			tarr.each{|t|
				if t["date"] == da then
					ttermine.push(t)	
				end
			}
		} 
		return ttermine
	end

	def properdate(tarr)
		tarr.each{|t|

			# padding with leading zeros and add the results as idividual keys to our hash
			t["day"] = "%02d" % t["date"].day.to_s
			t["month"] = "%02d" % t["date"].mon.to_s
			t["year"] = t["date"].year.to_s
			t["hour"] = "%02d" % t["date"].hour.to_s
			t["min"] = "%02d" % t["date"].min.to_s
	
			# translate numeric day of week to a meaningful string
			twd = t["date"].wday
			if twd == 0 then
				t["wday"] = "So"
			elsif twd == 1 then
				t["wday"] = "Mo"
			elsif twd == 2 then
				t["wday"] = "Di"
			elsif twd == 3 then
				t["wday"] = "Mi"
			elsif twd == 4 then
				t["wday"] = "Do"
			elsif twd == 5 then
				t["wday"] = "Fr"
			elsif twd == 6 then
				t["wday"] = "Sa"
			end

			t.delete("date")	# currently we do not need the comlete date anymore => delete it
		}
		return tarr
	end

	def outputtermine(tarr)
		puts "Debug output: content of events array of hashes"
		tarr.each{|t|
			puts "Termin"
			puts t["text"]
			puts t["link"]
			puts t["date"]
			puts t["year"]
			puts t["month"]
			puts t["day"]
			puts t["hour"]
			puts t["min"]
			puts t["wday"]
		}
	end

  # Main
	def run
		parsedtermine = parse()

		# all events
#		puts "handling all events ..."
		termine = sort(parsedtermine["termine"])
		@termine = properdate(termine)

		# non-recurring events only
#		puts "handling non-recurring events ..."
		nrtermine = sort(parsedtermine["nrtermine"])
		@nrtermine = properdate(nrtermine)	
	end
end



####
# MAIN
#

class Array
  def to_h
    Hash[*self]
  end
end



lt = LaborTermine.new;	# create instance
lt.run;	# run the parser

puts "Alle Termine:"
File.open( XMLFILE, "w" ) { |f|
  f.puts "<termine>"
  lt.termine.each { |termin|
    puts "#{termin["day"]}.#{termin["month"]}.#{termin["year"]} #{termin["hour"]}:#{termin["min"]} #{termin["text"]}"
    f.puts "<termin>"
      termin.each { |key,val|
        f.puts "  <#{key}>#{val}</#{key}>"
    	}
    f.puts "</termin>"
  }
  f.puts "</termine>"
}

puts "VortrÃ¤ge und Workshops:"
File.open( NRXMLFILE, "w" ) { |f|
  f.puts "<termine>"
  lt.nrtermine.each { |termin|
    puts "#{termin["day"]}.#{termin["month"]}.#{termin["year"]} #{termin["hour"]}:#{termin["min"]} #{termin["text"]}"
    f.puts "<termin>"
      termin.each { |key,val|
        f.puts "  <#{key}>#{val}</#{key}>"
    	}
    f.puts "</termin>"
  }
  f.puts "</termine>"
}
